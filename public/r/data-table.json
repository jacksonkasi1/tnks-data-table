{
  "name": "data-table",
  "type": "registry:ui",
  "title": "Advanced Data Table",
  "description": "A highly configurable and feature-rich data table component built on top of Shadcn UI and TanStack Table with server-side processing, row selection, export functionality, and more.",
  "dependencies": [
    "@tanstack/react-table",
    "@tanstack/react-query",
    "@hookform/resolvers",
    "react-hook-form",
    "zod",
    "sonner",
    "date-fns",
    "date-fns-tz",
    "xlsx",
    "class-variance-authority",
    "clsx",
    "tailwind-merge",
    "lucide-react",
    "react-day-picker",
    "cmdk"
  ],
  "registryDependencies": [
    "button",
    "checkbox",
    "input",
    "select",
    "popover",
    "calendar",
    "dropdown-menu",
    "separator",
    "table",
    "command"
  ],
  "files": [
    {
      "path": "registry/default/components/data-table/data-table.tsx",
      "type": "registry:component",
      "target": "components/data-table/data-table.tsx",
      "content": "\"use client\";\n\n// ** import types\nimport type * as React from \"react\";\nimport type { ColumnDef, ColumnResizeMode } from \"@tanstack/react-table\";\nimport type { TableConfig } from \"./utils/table-config\";\nimport type { CaseFormatConfig } from \"./utils/case-utils\";\nimport type { DataTransformFunction, ExportableData } from \"./utils/export-utils\";\n\n// ** import core packages\nimport {\n  type ColumnSizingState,\n  flexRender,\n  getCoreRowModel,\n  getFacetedRowModel,\n  getFacetedUniqueValues,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\";\nimport { useEffect, useCallback, useMemo, useRef, useState } from \"react\";\nimport { AlertCircle } from \"lucide-react\";\n\n// ** import components\nimport {\n  Table,\n  TableBody,\n  TableCell,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from \"@/components/ui/table\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { Alert, AlertDescription, AlertTitle } from \"@/components/ui/alert\";\nimport { DataTablePagination } from \"./pagination\";\nimport { DataTableToolbar } from \"./toolbar\";\nimport { DataTableResizer } from \"./data-table-resizer\";\n\n// ** import utils\nimport { useTableConfig } from \"./utils/table-config\";\nimport { useTableColumnResize } from \"./hooks/use-table-column-resize\";\nimport { preprocessSearch } from \"./utils/search\";\nimport {\n  createSortingHandler,\n  createColumnFiltersHandler,\n  createColumnVisibilityHandler,\n  createPaginationHandler,\n  createColumnSizingHandler,\n  createSortingState\n} from \"./utils/table-state-handlers\";\nimport { createKeyboardNavigationHandler } from \"./utils/keyboard-navigation\";\nimport { createConditionalStateHook } from \"./utils/conditional-state\";\nimport {\n  initializeColumnSizes,\n  trackColumnResizing,\n  cleanupColumnResizing\n} from \"./utils/column-sizing\";\n\n// Define types for the data fetching function params and result\ninterface DataFetchParams {\n  page: number;\n  limit: number;\n  search: string;\n  from_date: string;\n  to_date: string;\n  sort_by: string;\n  sort_order: string;\n}\n\ninterface DataFetchResult<TData> {\n  success: boolean;\n  data: TData[];\n  pagination: {\n    page: number;\n    limit: number;\n    total_pages: number;\n    total_items: number;\n  };\n}\n\n// Types for table handlers\ntype PaginationUpdater<TData> = (prev: { pageIndex: number; pageSize: number }) => { pageIndex: number; pageSize: number };\ntype SortingUpdater = (prev: { id: string; desc: boolean }[]) => { id: string; desc: boolean }[];\ntype ColumnOrderUpdater = (prev: string[]) => string[];\ntype RowSelectionUpdater = (prev: Record<string, boolean>) => Record<string, boolean>;\n\ninterface DataTableProps<TData extends ExportableData, TValue> {\n  // Allow overriding the table configuration\n  config?: Partial<TableConfig>;\n\n  // Column definitions generator\n  getColumns: (handleRowDeselection: ((rowId: string) => void) | null | undefined) => ColumnDef<TData, TValue>[];\n\n  // Data fetching function\n  fetchDataFn: ((params: DataFetchParams) => Promise<DataFetchResult<TData>>) | \n               ((page: number, pageSize: number, search: string, dateRange: { from_date: string; to_date: string }, sortBy: string, sortOrder: string, caseConfig?: CaseFormatConfig) => unknown);\n\n  // Function to fetch specific items by their IDs\n  fetchByIdsFn?: (ids: number[] | string[]) => Promise<TData[]>;\n\n  // Export configuration\n  exportConfig: {\n    entityName: string;\n    columnMapping: Record<string, string>;\n    columnWidths: Array<{ wch: number }>;\n    headers: string[];\n    caseConfig?: CaseFormatConfig;\n    transformFunction?: DataTransformFunction<TData>;\n  };\n\n  // ID field in TData for tracking selected items\n  idField: keyof TData;\n\n  // Custom page size options\n  pageSizeOptions?: number[];\n\n  // Custom toolbar content render function\n  renderToolbarContent?: (props: {\n    selectedRows: TData[];\n    allSelectedIds: string[];\n    totalSelectedCount: number;\n    resetSelection: () => void;\n  }) => React.ReactNode;\n\n  // Row click callback\n  onRowClick?: (rowData: TData, rowIndex: number) => void;\n}\n\nexport function DataTable<TData extends ExportableData, TValue>({\n  config = {},\n  getColumns,\n  fetchDataFn,\n  fetchByIdsFn,\n  exportConfig,\n  idField = 'id' as keyof TData,\n  pageSizeOptions,\n  renderToolbarContent,\n  onRowClick\n}: DataTableProps<TData, TValue>) {\n  // Load table configuration with any overrides\n  const tableConfig = useTableConfig(config);\n\n  // Table ID for localStorage storage - generate a default if not provided\n  const tableId = tableConfig.columnResizingTableId || 'data-table-default';\n\n  // Use our custom hook for column resizing\n  const { columnSizing, setColumnSizing, resetColumnSizing } = useTableColumnResize(\n    tableId,\n    tableConfig.enableColumnResizing\n  );\n\n  // Create conditional URL state hook based on config\n  const useConditionalUrlState = createConditionalStateHook(tableConfig.enableUrlState);\n\n  // States for API parameters using conditional URL state\n  const [page, setPage] = useConditionalUrlState(\"page\", 1);\n  const [pageSize, setPageSize] = useConditionalUrlState(\"pageSize\", 10);\n  const [search, setSearch] = useConditionalUrlState(\"search\", \"\");\n  const [dateRange, setDateRange] = useConditionalUrlState<{ from_date: string; to_date: string }>(\"dateRange\", { from_date: \"\", to_date: \"\" });\n  const [sortBy, setSortBy] = useConditionalUrlState(\"sortBy\", tableConfig.defaultSortBy || \"id\");\n  const [sortOrder, setSortOrder] = useConditionalUrlState<\"asc\" | \"desc\">(\"sortOrder\", tableConfig.defaultSortOrder || \"desc\");\n  const [columnVisibility, setColumnVisibility] = useConditionalUrlState<Record<string, boolean>>(\"columnVisibility\", {});\n  const [columnFilters, setColumnFilters] = useConditionalUrlState<Array<{ id: string; value: unknown }>>(\"columnFilters\", []);\n\n  // Internal states\n  const [isLoading, setIsLoading] = useState(true);\n  const [isError, setIsError] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [data, setData] = useState<{\n    data: TData[];\n    pagination: {\n      page: number;\n      limit: number;\n      total_pages: number;\n      total_items: number;\n    };\n  } | null>(null);\n\n  // Column order state (managed separately from URL state as it's persisted in localStorage)\n  const [columnOrder, setColumnOrder] = useState<string[]>([]);\n\n  // PERFORMANCE FIX: Use only one selection state as the source of truth\n  // All IDs are stored as strings for consistency\n  const [selectedItemIds, setSelectedItemIds] = useState<Record<string, boolean>>({});\n\n  // Convert the sorting from URL to the format TanStack Table expects\n  const sorting = useMemo(() => createSortingState(sortBy, sortOrder), [sortBy, sortOrder]);\n\n  // Get current data items - memoize to avoid recalculations\n  const dataItems = useMemo(() => data?.data || [], [data?.data]);\n\n  // PERFORMANCE FIX: Derive rowSelection from selectedItemIds using memoization\n  const rowSelection = useMemo(() => {\n    if (!dataItems.length) return {};\n\n    // Map selectedItemIds to row indices for the table\n    const selection: Record<string, boolean> = {};\n\n    dataItems.forEach((item, index) => {\n      const itemId = String(item[idField]);\n      if (selectedItemIds[itemId]) {\n        selection[String(index)] = true;\n      }\n    });\n\n    return selection;\n  }, [dataItems, selectedItemIds, idField]);\n\n  // Calculate total selected items - memoize to avoid recalculation\n  const totalSelectedItems = useMemo(() =>\n    Object.keys(selectedItemIds).length,\n    [selectedItemIds]\n  );\n\n  // PERFORMANCE FIX: Optimized row deselection handler\n  const handleRowDeselection = useCallback((rowId: string) => {\n    if (!dataItems.length) return;\n\n    const rowIndex = Number.parseInt(rowId, 10);\n    const item = dataItems[rowIndex];\n\n    if (item) {\n      const itemId = String(item[idField]);\n      setSelectedItemIds(prev => {\n        // Remove this item ID from selection\n        const next = { ...prev };\n        delete next[itemId];\n        return next;\n      });\n    }\n  }, [dataItems, idField]);\n\n  // Clear all selections\n  const clearAllSelections = useCallback(() => {\n    setSelectedItemIds({});\n  }, []);\n\n  // PERFORMANCE FIX: Optimized row selection handler\n  const handleRowSelectionChange = useCallback((updaterOrValue: RowSelectionUpdater | Record<string, boolean>) => {\n    // Determine the new row selection value\n    const newRowSelection = typeof updaterOrValue === 'function'\n      ? updaterOrValue(rowSelection)\n      : updaterOrValue;\n\n    // Batch update selectedItemIds based on the new row selection\n    setSelectedItemIds(prev => {\n      const next = { ...prev };\n\n      // Process changes for current page\n      if (dataItems.length) {\n        // First handle explicit selections in newRowSelection\n        for (const [rowId, isSelected] of Object.entries(newRowSelection)) {\n          const rowIndex = Number.parseInt(rowId, 10);\n          if (rowIndex >= 0 && rowIndex < dataItems.length) {\n            const item = dataItems[rowIndex];\n            const itemId = String(item[idField]);\n\n            if (isSelected) {\n              next[itemId] = true;\n            } else {\n              delete next[itemId];\n            }\n          }\n        }\n\n        // Then handle implicit deselection (rows that were selected but aren't in newRowSelection)\n        dataItems.forEach((item, index) => {\n          const itemId = String(item[idField]);\n          const rowId = String(index);\n\n          // If item was selected but isn't in new selection, deselect it\n          if (prev[itemId] && newRowSelection[rowId] === undefined) {\n            delete next[itemId];\n          }\n        });\n      }\n\n      return next;\n    });\n  }, [dataItems, rowSelection, idField]);\n\n  // Get selected items data\n  const getSelectedItems = useCallback(async () => {\n    // If nothing is selected, return empty array\n    if (totalSelectedItems === 0) {\n      return [];\n    }\n\n    // Get IDs of selected items - determine if they are strings or numbers\n    const selectedIdsArray = Object.keys(selectedItemIds);\n\n    // Check if the first item ID is a number to determine the type\n    const isNumericIds = dataItems.length > 0 && typeof dataItems[0][idField] === 'number';\n\n    // Find items from current page that are selected\n    const itemsInCurrentPage = dataItems.filter(item =>\n      selectedItemIds[String(item[idField])]\n    );\n\n    // Get IDs of items on current page\n    const idsInCurrentPage = itemsInCurrentPage.map(item => String(item[idField]));\n\n    // Find IDs that need to be fetched (not on current page)\n    const idsToFetchRaw = selectedIdsArray.filter(id =>\n      !idsInCurrentPage.includes(id)\n    );\n\n    // Convert IDs to the appropriate type for the fetchByIdsFn\n    const idsToFetch = isNumericIds\n      ? idsToFetchRaw.map(id => Number.parseInt(id, 10)).filter(id => !Number.isNaN(id))\n      : idsToFetchRaw;\n\n    // If all selected items are on current page or we can't fetch by IDs\n    if (idsToFetch.length === 0 || !fetchByIdsFn) {\n      return itemsInCurrentPage;\n    }\n\n    try {\n      // Fetch missing items in a single batch - TypeScript will infer the correct type\n      const fetchedItems = await fetchByIdsFn(idsToFetch as number[] | string[]);\n\n      // Combine current page items with fetched items\n      return [...itemsInCurrentPage, ...fetchedItems];\n    } catch (error) {\n      console.error(\"Error fetching selected items:\", error);\n      return itemsInCurrentPage;\n    }\n  }, [dataItems, selectedItemIds, totalSelectedItems, fetchByIdsFn, idField]);\n\n  // Get all items on current page\n  const getAllItems = useCallback((): TData[] => {\n    // Return current page data\n    return dataItems;\n  }, [dataItems]);\n\n  // Fetch data\n  useEffect(() => {\n    // Check if the fetchDataFn is a query hook\n    const isQueryHook = (fetchDataFn as { isQueryHook?: boolean }).isQueryHook === true;\n\n    if (!isQueryHook) {\n      // Create refs to capture the current sort values at the time of fetching\n      const currentSortBy = sortBy;\n      const currentSortOrder = sortOrder;\n      \n      const fetchData = async () => {\n        try {\n          setIsLoading(true);\n          \n          const result = await (fetchDataFn as (params: DataFetchParams) => Promise<DataFetchResult<TData>>)({\n            page,\n            limit: pageSize,\n            search: preprocessSearch(search),\n            from_date: dateRange.from_date,\n            to_date: dateRange.to_date,\n            sort_by: currentSortBy,\n            sort_order: currentSortOrder,\n          });\n          setData(result);\n          setIsError(false);\n          setError(null);\n        } catch (err) {\n          setIsError(true);\n          setError(err instanceof Error ? err : new Error(\"Unknown error\"));\n          console.error(\"Error fetching data:\", err);\n        } finally {\n          setIsLoading(false);\n        }\n      };\n\n      fetchData();\n    }\n  }, [page, pageSize, search, dateRange, sortBy, sortOrder, fetchDataFn]);\n\n  // If fetchDataFn is a React Query hook, call it directly with parameters\n  const queryResult = (fetchDataFn as { isQueryHook?: boolean }).isQueryHook === true\n    ? (fetchDataFn as (page: number, pageSize: number, search: string, dateRange: { from_date: string; to_date: string }, sortBy: string, sortOrder: string, caseConfig?: CaseFormatConfig) => { \n        isLoading: boolean; \n        isSuccess: boolean; \n        isError: boolean; \n        data?: DataFetchResult<TData>; \n        error?: Error \n      })(\n        page, \n        pageSize, \n        search, \n        dateRange, \n        sortBy,\n        sortOrder,\n        exportConfig.caseConfig\n      )\n    : null;\n\n  // If using React Query, update state based on query result\n  useEffect(() => {\n    if (queryResult) {\n      setIsLoading(queryResult.isLoading);\n      if (queryResult.isSuccess && queryResult.data) {\n        setData(queryResult.data);\n        setIsError(false);\n        setError(null);\n      }\n      if (queryResult.isError) {\n        setIsError(true);\n        setError(queryResult.error instanceof Error ? queryResult.error : new Error(\"Unknown error\"));\n      }\n    }\n  }, [queryResult]);\n\n  // Memoized pagination state\n  const pagination = useMemo(\n    () => ({\n      pageIndex: page - 1,\n      pageSize,\n    }),\n    [page, pageSize]\n  );\n\n  // Ref for the table container for keyboard navigation\n  const tableContainerRef = useRef<HTMLDivElement>(null);\n\n  // Get columns with the deselection handler (memoize to avoid recreation on render)\n  const columns = useMemo(() => {\n    // Only pass deselection handler if row selection is enabled\n    return getColumns(tableConfig.enableRowSelection ? handleRowDeselection : null);\n  }, [getColumns, handleRowDeselection, tableConfig.enableRowSelection]);\n\n  // Create event handlers using utility functions\n  const handleSortingChange = useCallback(\n    (updaterOrValue: SortingUpdater | { id: string; desc: boolean }[]) => {\n      // Extract the new sorting state\n      const newSorting = typeof updaterOrValue === 'function'\n        ? updaterOrValue(sorting)\n        : updaterOrValue;\n      \n      if (newSorting.length > 0) {\n        const columnId = newSorting[0].id;\n        const direction = newSorting[0].desc ? \"desc\" : \"asc\";\n        // Use Promise.all for batch updates to ensure they're applied together\n        Promise.all([\n          setSortBy(columnId),\n          setSortOrder(direction)\n        ]).catch(err => {\n          console.error(\"Failed to update URL sorting params:\", err);\n        });\n      }\n    },\n    [setSortBy, setSortOrder, sorting]\n  );\n\n  const handleColumnFiltersChange = useCallback(\n    createColumnFiltersHandler(setColumnFilters),\n    []\n  );\n\n  const handleColumnVisibilityChange = useCallback(\n    createColumnVisibilityHandler(setColumnVisibility),\n    []\n  );\n\n  const handlePaginationChange = useCallback(\n    (updaterOrValue: PaginationUpdater<TData> | { pageIndex: number; pageSize: number }) => {\n      // Extract the new pagination state\n      const newPagination = typeof updaterOrValue === 'function'\n        ? updaterOrValue({ pageIndex: page - 1, pageSize })\n        : updaterOrValue;\n      \n      // Special handling: When page size changes, always reset to page 1\n      if (newPagination.pageSize !== pageSize) {\n        // First, directly update URL to ensure it's in sync\n        const url = new URL(window.location.href);\n        url.searchParams.set('pageSize', String(newPagination.pageSize));\n        url.searchParams.set('page', '1'); // Always reset to page 1\n        window.history.replaceState({}, '', url.toString());\n        \n        // Then update our state\n        setPageSize(newPagination.pageSize);\n        setPage(1);\n        return;\n      }\n      \n      // Only update page if it's changed - this handles normal page navigation\n      if ((newPagination.pageIndex + 1) !== page) {\n        const setPagePromise = setPage(newPagination.pageIndex + 1);\n        if (setPagePromise && typeof setPagePromise.catch === 'function') {\n          setPagePromise.catch(err => {\n            console.error(\"Failed to update page param:\", err);\n          });\n        }\n      }\n    },\n    [page, pageSize, setPage, setPageSize]\n  );\n\n  const handleColumnSizingChange = useCallback(\n    (updaterOrValue: ColumnSizingState | ((prev: ColumnSizingState) => ColumnSizingState)) => {\n      if (typeof updaterOrValue === 'function') {\n        setColumnSizing(current => updaterOrValue(current));\n      } else {\n        setColumnSizing(updaterOrValue);\n      }\n    },\n    [setColumnSizing]\n  );\n\n  // Column order change handler\n  const handleColumnOrderChange = useCallback((updaterOrValue: ColumnOrderUpdater | string[]) => {\n    const newColumnOrder = typeof updaterOrValue === 'function'\n      ? updaterOrValue(columnOrder)\n      : updaterOrValue;\n\n    setColumnOrder(newColumnOrder);\n\n    // Persist column order to localStorage\n    try {\n      localStorage.setItem('data-table-column-order', JSON.stringify(newColumnOrder));\n    } catch (error) {\n      console.error('Failed to save column order to localStorage:', error);\n    }\n  }, [columnOrder]);\n\n  // Load column order from localStorage on initial render\n  useEffect(() => {\n    try {\n      const savedOrder = localStorage.getItem('data-table-column-order');\n      if (savedOrder) {\n        const parsedOrder = JSON.parse(savedOrder);\n        // Validate array of strings\n        if (Array.isArray(parsedOrder) && parsedOrder.every(item => typeof item === 'string')) {\n          setColumnOrder(parsedOrder);\n        } else {\n          console.warn('Invalid column order format, ignoring');\n          localStorage.removeItem('data-table-column-order');\n        }\n      }\n    } catch (error) {\n      console.error('Error loading column order:', error);\n      localStorage.removeItem('data-table-column-order');\n    }\n  }, []);\n\n  // Memoize table configuration to prevent unnecessary re-renders\n  const tableOptions = useMemo(() => ({\n    data: dataItems,\n    columns,\n    state: {\n      sorting,\n      columnVisibility,\n      rowSelection,\n      columnFilters,\n      pagination,\n      columnSizing,\n      columnOrder,\n    },\n    columnResizeMode: 'onChange' as ColumnResizeMode,\n    onColumnSizingChange: handleColumnSizingChange,\n    onColumnOrderChange: handleColumnOrderChange,\n    pageCount: data?.pagination.total_pages || 0,\n    enableRowSelection: tableConfig.enableRowSelection,\n    enableColumnResizing: tableConfig.enableColumnResizing,\n    manualPagination: true,\n    manualSorting: true,\n    manualFiltering: true,\n    onRowSelectionChange: handleRowSelectionChange,\n    onSortingChange: handleSortingChange,\n    onColumnFiltersChange: handleColumnFiltersChange,\n    onColumnVisibilityChange: handleColumnVisibilityChange,\n    onPaginationChange: handlePaginationChange,\n    getCoreRowModel: getCoreRowModel<TData>(),\n    getFilteredRowModel: getFilteredRowModel<TData>(),\n    getPaginationRowModel: getPaginationRowModel<TData>(),\n    getSortedRowModel: getSortedRowModel<TData>(),\n    getFacetedRowModel: getFacetedRowModel<TData>(),\n    getFacetedUniqueValues: getFacetedUniqueValues<TData>(),\n  }), [\n    dataItems,\n    columns,\n    sorting,\n    columnVisibility,\n    rowSelection,\n    columnFilters,\n    pagination,\n    columnSizing,\n    columnOrder,\n    handleColumnSizingChange,\n    handleColumnOrderChange,\n    data?.pagination.total_pages,\n    tableConfig.enableRowSelection,\n    tableConfig.enableColumnResizing,\n    handleRowSelectionChange,\n    handleSortingChange,\n    handleColumnFiltersChange,\n    handleColumnVisibilityChange,\n    handlePaginationChange,\n  ]);\n\n  // Set up the table with memoized configuration\n  const table = useReactTable<TData>(tableOptions);\n\n  // Row click handler with conflict prevention\n  const handleRowClick = useCallback((event: React.MouseEvent, rowData: TData, rowIndex: number) => {\n    // Prevent row click if clicking on interactive elements (buttons, links, etc.)\n    const target = event.target as HTMLElement;\n    const isInteractiveElement = target.closest('button, a, input, select, textarea, [role=\"button\"], [role=\"link\"]');\n    \n    if (isInteractiveElement) {\n      return;\n    }\n\n    // Call the onRowClick callback if provided\n    onRowClick?.(rowData, rowIndex);\n  }, [onRowClick]);\n\n  // Create keyboard navigation handler\n  const handleKeyDown = useCallback(\n    createKeyboardNavigationHandler(table, onRowClick ? (rowData: TData, rowIndex: number) => {\n      // Handle keyboard activation (Enter/Space) for row clicks\n      onRowClick(rowData, rowIndex);\n    } : undefined),\n    [onRowClick]\n  );\n\n  // Add an effect to validate page number when page size changes\n  useEffect(() => {\n    // This effect ensures page is valid after page size changes\n    const totalPages = data?.pagination.total_pages || 0;\n    \n    if (totalPages > 0 && page > totalPages) {\n      setPage(1);\n    }\n  }, [data?.pagination?.total_pages, page, setPage]);\n\n  // Initialize default column sizes when columns are available and no saved sizes exist\n  useEffect(() => {\n    initializeColumnSizes(columns as ColumnDef<TData, unknown>[], tableId, setColumnSizing);\n  }, [columns, tableId, setColumnSizing]);\n\n  // Handle column resizing\n  useEffect(() => {\n    const isResizingAny =\n      table.getHeaderGroups().some(headerGroup =>\n        headerGroup.headers.some(header => header.column.getIsResizing())\n      );\n\n    trackColumnResizing(isResizingAny);\n\n    // Cleanup on unmount\n    return () => {\n      cleanupColumnResizing();\n    };\n  }, [table]);\n\n  // Reset column order\n  const resetColumnOrder = useCallback(() => {\n    // Reset to empty array (which resets to default order)\n    table.setColumnOrder([]);\n    setColumnOrder([]);\n\n    // Remove from localStorage\n    try {\n      localStorage.removeItem('data-table-column-order');\n    } catch (error) {\n      console.error('Failed to remove column order from localStorage:', error);\n    }\n  }, [table]);\n\n  // Add synchronization effect to ensure URL is the source of truth\n  useEffect(() => {\n    // Force the table's sorting state to match URL parameters\n    table.setSorting(sorting);\n  }, [table, sorting]);\n\n  // Keep pagination in sync with URL parameters\n  useEffect(() => {\n    // Make sure table pagination state matches URL state\n    const tableState = table.getState().pagination;\n    if (tableState.pageIndex !== page - 1 || tableState.pageSize !== pageSize) {\n      // Avoid unnecessary updates that might cause infinite loops\n      if (tableState.pageSize !== pageSize || Math.abs(tableState.pageIndex - (page - 1)) > 0) {\n        table.setPagination({\n          pageIndex: page - 1,\n          pageSize: pageSize\n        });\n      }\n    }\n  }, [table, page, pageSize]);\n\n  // Handle error state\n  if (isError) {\n    return (\n      <Alert variant=\"destructive\" className=\"my-4\">\n        <AlertCircle className=\"h-4 w-4\" />\n        <AlertTitle>Error</AlertTitle>\n        <AlertDescription>\n          Failed to load data: {error instanceof Error ? error.message : \"Unknown error\"}\n        </AlertDescription>\n      </Alert>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      {tableConfig.enableToolbar && (\n        <DataTableToolbar\n          table={table}\n          setSearch={setSearch}\n          setDateRange={setDateRange}\n          totalSelectedItems={totalSelectedItems}\n          deleteSelection={clearAllSelections}\n          getSelectedItems={getSelectedItems}\n          getAllItems={getAllItems}\n          config={tableConfig}\n          resetColumnSizing={() => {\n            resetColumnSizing();\n            // Force a small delay and then refresh the UI\n            setTimeout(() => {\n              window.dispatchEvent(new Event('resize'));\n            }, 100);\n          }}\n          resetColumnOrder={resetColumnOrder}\n          entityName={exportConfig.entityName}\n          columnMapping={exportConfig.columnMapping}\n          columnWidths={exportConfig.columnWidths}\n          headers={exportConfig.headers}\n          transformFunction={exportConfig.transformFunction}\n          customToolbarComponent={renderToolbarContent?.({\n            selectedRows: dataItems.filter((item) => selectedItemIds[String(item[idField])]),\n            allSelectedIds: Object.keys(selectedItemIds),\n            totalSelectedCount: totalSelectedItems,\n            resetSelection: clearAllSelections\n          })}\n        />\n      )}\n\n      <div\n        ref={tableContainerRef}\n        className=\"overflow-y-auto rounded-md border table-container\"\n        aria-label=\"Data table\"\n        onKeyDown={tableConfig.enableKeyboardNavigation ? handleKeyDown : undefined}\n      >\n        <Table className={tableConfig.enableColumnResizing ? \"resizable-table\" : \"\"}>\n          <TableHeader>\n            {table.getHeaderGroups().map((headerGroup) => (\n              <TableRow\n                key={headerGroup.id}\n              >\n                {headerGroup.headers.map((header) => (\n                  <TableHead\n                    className=\"px-2 py-2 relative text-left group/th\"\n                    key={header.id}\n                    colSpan={header.colSpan}\n                    scope=\"col\"\n                    tabIndex={-1}\n                    style={{\n                      width: header.getSize(),\n                    }}\n                    data-column-resizing={header.column.getIsResizing() ? \"true\" : undefined}\n                  >\n                    {header.isPlaceholder\n                      ? null\n                      : flexRender(\n                          header.column.columnDef.header,\n                          header.getContext(),\n                        )}\n                    {tableConfig.enableColumnResizing && header.column.getCanResize() && (\n                      <DataTableResizer header={header} table={table} />\n                    )}\n                  </TableHead>\n                ))}\n              </TableRow>\n            ))}\n          </TableHeader>\n\n          <TableBody>\n            {isLoading ? (\n              // Loading state\n              Array.from({ length: pageSize }).map((_, i) => (\n                <TableRow\n                  key={`loading-row-${crypto.randomUUID()}`}\n                  tabIndex={-1}\n                >\n                  {Array.from({ length: columns.length }).map((_, j, array) => (\n                    <TableCell\n                      key={`skeleton-cell-${crypto.randomUUID()}`}\n                      className=\"px-4 py-2 truncate max-w-0 text-left\"\n                      tabIndex={-1}\n                    >\n                      <Skeleton className=\"h-6 w-full\" />\n                    </TableCell>\n                  ))}\n                </TableRow>\n              ))\n            ) : table.getRowModel().rows?.length ? (\n              // Data rows\n              table.getRowModel().rows.map((row, rowIndex) => (\n                <TableRow\n                  key={row.id}\n                  id={`row-${rowIndex}`}\n                  data-row-index={rowIndex}\n                  data-state={row.getIsSelected() ? \"selected\" : undefined}\n                  tabIndex={0}\n                  aria-selected={row.getIsSelected()}\n                  onClick={(event) => {\n                    // Handle click row select if enabled\n                    if (tableConfig.enableClickRowSelect) {\n                      row.toggleSelected();\n                    }\n                    // Handle custom row click callback\n                    if (onRowClick) {\n                      handleRowClick(event, row.original, rowIndex);\n                    }\n                  }}\n                  onFocus={(e) => {\n                    // Add a data attribute to the currently focused row\n                    for (const el of document.querySelectorAll('[data-focused=\"true\"]')) {\n                      el.removeAttribute('data-focused');\n                    }\n                    e.currentTarget.setAttribute('data-focused', 'true');\n                  }}\n                  style={{\n                    cursor: onRowClick ? 'pointer' : undefined\n                  }}\n                >\n                  {row.getVisibleCells().map((cell, cellIndex) => (\n                    <TableCell\n                      className=\"px-4 py-2 truncate max-w-0 text-left\"\n                      key={cell.id}\n                      id={`cell-${rowIndex}-${cellIndex}`}\n                      data-cell-index={cellIndex}\n                    >\n                      {flexRender(\n                        cell.column.columnDef.cell,\n                        cell.getContext(),\n                      )}\n                    </TableCell>\n                  ))}\n                </TableRow>\n              ))\n            ) : (\n              // No results\n              <TableRow>\n                <TableCell\n                  colSpan={columns.length}\n                  className=\"h-24 text-left truncate\"\n                >\n                  No results.\n                </TableCell>\n              </TableRow>\n            )}\n          </TableBody>\n        </Table>\n      </div>\n\n      {tableConfig.enablePagination && (\n        <DataTablePagination\n          table={table}\n          totalItems={data?.pagination.total_items || 0}\n          totalSelectedItems={totalSelectedItems}\n          pageSizeOptions={pageSizeOptions || [10, 20, 30, 40, 50]}\n          size={tableConfig.size}\n        />\n      )}\n    </div>\n  );\n}"
    },
    {
      "path": "registry/default/components/data-table/column-header.tsx",
      "type": "registry:component",
      "target": "components/data-table/column-header.tsx",
      "content": "import {\n  ArrowDownIcon,\n  ArrowUpIcon,\n  CaretSortIcon,\n  EyeNoneIcon,\n} from \"@radix-ui/react-icons\";\nimport type { Column } from \"@tanstack/react-table\";\n\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger\n} from \"@/components/ui/dropdown-menu\";\n\n\ninterface DataTableColumnHeaderProps<TData, TValue>\n  extends React.HTMLAttributes<HTMLDivElement> {\n  column: Column<TData, TValue>;\n  title: string;\n}\n\nexport function DataTableColumnHeader<TData, TValue>({\n  column,\n  title,\n  className\n}: DataTableColumnHeaderProps<TData, TValue>) {\n  if (!column.getCanSort()) {\n    return <div className={cn(className)}>{title}</div>;\n  }\n\n  // Get the current sort direction for this column\n  const currentDirection = column.getIsSorted();\n\n  // Use direct method to set sort with an explicit direction\n  const setSorting = (direction: \"asc\" | \"desc\" | false) => {\n    // If we're clearing sort, use an empty array\n    if (direction === false) {\n      column.toggleSorting(undefined, false);\n      return;\n    }\n\n    // Set explicit sort with the direction\n    // The second param (false) prevents multi-sort\n    column.toggleSorting(direction === \"desc\", false);\n  };\n\n  return (\n    <div className={cn(\"flex items-center space-x-2\", className)}>\n      <DropdownMenu>\n        <DropdownMenuTrigger asChild>\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            className=\"data-[state=open]:bg-accent h-8 focus-visible:ring-0 focus-visible:ring-offset-0\"\n          >\n            <span>{title}</span>\n            {currentDirection === \"desc\" ? (\n              <ArrowDownIcon className=\"ml-2 h-4 w-4\" />\n            ) : currentDirection === \"asc\" ? (\n              <ArrowUpIcon className=\"ml-2 h-4 w-4\" />\n            ) : (\n              <CaretSortIcon className=\"ml-2 h-4 w-4\" />\n            )}\n          </Button>\n        </DropdownMenuTrigger>\n        <DropdownMenuContent align=\"start\">\n          <DropdownMenuItem onClick={() => setSorting(\"asc\")}>\n            <ArrowUpIcon className=\"mr-2 h-3.5 w-3.5 text-muted-foreground/70\" />\n            Asc\n          </DropdownMenuItem>\n          <DropdownMenuItem onClick={() => setSorting(\"desc\")}>\n            <ArrowDownIcon className=\"mr-2 h-3.5 w-3.5 text-muted-foreground/70\" />\n            Desc\n          </DropdownMenuItem>\n          <DropdownMenuSeparator />\n          <DropdownMenuItem  onClick={() => column.toggleVisibility(false)}>\n            <EyeNoneIcon className=\"mr-2 h-3.5 w-3.5 text-muted-foreground/70\" />\n            Hide\n          </DropdownMenuItem>\n        </DropdownMenuContent>\n      </DropdownMenu>\n    </div>\n  );\n}"
    },
    {
      "path": "registry/default/components/data-table/data-export.tsx",
      "type": "registry:component",
      "target": "components/data-table/data-export.tsx",
      "content": "\"use client\";\n\n// ** import types\nimport type { JSX } from \"react\";\nimport type { Table } from \"@tanstack/react-table\";\nimport type { ExportableData, DataTransformFunction } from \"./utils/export-utils\";\nimport type { TableConfig } from \"./utils/table-config\";\n\n// ** import core packages\nimport { useState } from \"react\";\nimport { DownloadIcon, Loader2 } from \"lucide-react\";\nimport { toast } from \"sonner\";\n\n// ** import components\nimport { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\n\n// ** import utils\nimport { exportData, exportToCSV, exportToExcel } from \"./utils/export-utils\";\n\ninterface DataTableExportProps<TData extends ExportableData> {\n  table: Table<TData>;\n  data: TData[];\n  selectedData?: TData[];\n  getSelectedItems?: () => Promise<TData[]>;\n  getAllItems?: () => Promise<TData[]>;\n  entityName?: string;\n  columnMapping?: Record<string, string>;\n  columnWidths?: Array<{ wch: number }>;\n  headers?: string[];\n  transformFunction?: DataTransformFunction<TData>;\n  size?: 'sm' | 'default' | 'lg';\n  config?: TableConfig;\n}\n\nexport function DataTableExport<TData extends ExportableData>({\n  table,\n  data,\n  selectedData,\n  getSelectedItems,\n  getAllItems,\n  entityName = \"items\",\n  columnMapping,\n  columnWidths,\n  headers,\n  transformFunction,\n  size = 'default',\n  config\n}: DataTableExportProps<TData>): JSX.Element {\n  const [isLoading, setIsLoading] = useState(false);\n\n  const handleExport = async (type: \"csv\" | \"excel\") => {\n    if (isLoading) return; // Prevent multiple export requests\n    \n    // Create a data fetching function based on the current state\n    const fetchExportData = async (): Promise<TData[]> => {\n      // If we have selected items and a function to get their complete data\n      if (getSelectedItems && selectedData && selectedData.length > 0) {\n        // Check if data is on current page or needs to be fetched\n        if (selectedData.some(item => Object.keys(item).length === 0)) {\n          // We have placeholder data, need to fetch complete data\n          toast.loading(\"Preparing export...\", {\n            description: `Fetching complete data for selected ${entityName}.`,\n            id: \"export-data-toast\",\n          });\n        }\n        \n        // Fetch complete data for selected items\n        const selectedItems = await getSelectedItems();\n        \n        if (selectedItems.length === 0) {\n          throw new Error(`Failed to retrieve complete data for selected ${entityName}`);\n        }\n        \n        // Order the items according to the current sorting in the table\n        // This preserves the table's page order in the exported data\n        const sortedItems = [...selectedItems];\n        const sorting = table.getState().sorting;\n        \n        if (sorting.length > 0) {\n          const { id: sortField, desc: isDescending } = sorting[0];\n\n          // Check if array is empty before accessing first item\n          if (sortedItems.length === 0) {\n            return sortedItems;\n          }\n\n          // Validate that sortField exists in data before sorting\n          const sampleItem = sortedItems[0];\n          if (!(sortField in sampleItem)) {\n            console.warn(`Sort field \"${sortField}\" not found in data. Skipping sort.`);\n            return sortedItems;\n          }\n          \n          sortedItems.sort((a, b) => {\n            try {\n              const valueA = a[sortField as keyof TData];\n              const valueB = b[sortField as keyof TData];\n              \n              if (valueA === valueB) return 0;\n              \n              if (valueA === null || valueA === undefined) return isDescending ? 1 : -1;\n              if (valueB === null || valueB === undefined) return isDescending ? -1 : 1;\n              \n              if (typeof valueA === 'string' && typeof valueB === 'string') {\n              return isDescending \n                ? valueB.localeCompare(valueA) \n                : valueA.localeCompare(valueB);\n            }\n            \n              // For numeric and other comparable types\n              return isDescending \n                ? (valueB > valueA ? 1 : -1) \n                : (valueA > valueB ? 1 : -1);\n            } catch (sortError) {\n              console.error('Error during sorting:', sortError);\n              return 0; // Maintain original order on error\n            }\n          });\n        }\n        \n        return sortedItems;\n      } else if (getAllItems && !selectedData?.length) {\n        // If we're exporting all data and have a method to get it with proper ordering\n        toast.loading(\"Preparing export...\", {\n          description: `Fetching all ${entityName} with current sorting...`,\n          id: \"export-data-toast\",\n        });\n        \n        // Fetch all data with server-side sorting applied\n        const allItems = await getAllItems();\n        \n        if (allItems.length === 0) {\n          throw new Error(`No ${entityName} available to export`);\n        }\n        \n        return allItems;\n      } else {\n        // Otherwise use the provided data (current page data)\n        if (!data || data.length === 0) {\n          throw new Error(\"No data available for export\");\n        }\n        return selectedData && selectedData.length > 0 ? selectedData : data;\n      }\n    };\n\n    try {\n      // Get visible columns from the table\n      const visibleColumns = table.getAllColumns()\n        .filter(column => column.getIsVisible())\n        .filter(column => column.id !== 'actions' && column.id !== 'select');\n\n      // Generate export options based on visible columns and respect column order\n      const columnOrder = table.getState().columnOrder;\n      const orderedVisibleColumns = columnOrder.length > 0\n        ? [...visibleColumns].sort((a, b) => {\n            const aIndex = columnOrder.indexOf(a.id);\n            const bIndex = columnOrder.indexOf(b.id);\n            // If column isn't in the order array, put it at the end\n            if (aIndex === -1) return 1;\n            if (bIndex === -1) return -1;\n            return aIndex - bIndex;\n          })\n        : visibleColumns;\n\n      // Generate export headers - always start with visible columns only\n      const visibleColumnIds = orderedVisibleColumns.map(column => column.id);\n      // Get all table column IDs (visible + hidden) to identify what's a table column vs transform column\n      const allTableColumnIds = table.getAllColumns()\n        .filter(column => column.id !== 'actions' && column.id !== 'select')\n        .map(column => column.id);\n      \n      let exportHeaders: string[];\n      \n      if (config?.allowExportNewColumns === false) {\n        // Only export visible columns - no new columns from transform\n        exportHeaders = headers && headers.length > 0 \n          ? headers.filter(header => visibleColumnIds.includes(header))\n          : visibleColumnIds;\n      } else {\n        // Allow new columns from transform function, but still filter existing columns by visibility\n        if (headers && headers.length > 0) {\n          // Split headers into existing table columns (must be visible) and new transform columns (allowed)\n          const existingHeaders = headers.filter(header => allTableColumnIds.includes(header) && visibleColumnIds.includes(header));\n          const newHeaders = headers.filter(header => !allTableColumnIds.includes(header));\n          exportHeaders = [...existingHeaders, ...newHeaders];\n        } else {\n          exportHeaders = visibleColumnIds;\n        }\n      }\n\n      // Auto-generate column mapping from table headers if not provided\n      const exportColumnMapping = columnMapping || (() => {\n        const mapping: Record<string, string> = {};\n        orderedVisibleColumns.forEach(column => {\n          // Try to get header text if available\n          const headerText = column.columnDef.header as string;\n          \n          if (headerText && typeof headerText === 'string') {\n            mapping[column.id] = headerText;\n          } else {\n            // Fallback to formatted column ID\n            mapping[column.id] = column.id\n              .split(/(?=[A-Z])|_/)\n              .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n              .join(' ');\n          }\n        });\n        return mapping;\n      })();\n\n      // Filter column widths to match export headers\n      const exportColumnWidths = columnWidths ? \n        exportHeaders.map((_, index) => columnWidths[index] || { wch: 15 }) :\n        exportHeaders.map(() => ({ wch: 15 }));\n\n      // Use the generic export function with proper options\n      await exportData(\n        type,\n        fetchExportData,\n        () => setIsLoading(true),\n        () => setIsLoading(false),\n        {\n          entityName,\n          headers: exportHeaders,\n          columnMapping: exportColumnMapping,\n          columnWidths: exportColumnWidths,\n          transformFunction\n        }\n      );\n    } catch (error) {\n      console.error(\"Error exporting data:\", error);\n      toast.error(\"Export failed\", {\n        description: \"There was a problem exporting. Please try again.\",\n        id: \"export-data-toast\"\n      });\n      setIsLoading(false);\n    }\n  };\n\n  const exportAllPages = async (type: \"csv\" | \"excel\") => {\n    if (isLoading || !getAllItems) return;\n    setIsLoading(true);\n    \n    try {\n      // Show toast for long operations\n      toast.loading(\"Preparing export...\", {\n        description: `Fetching all ${entityName}...`,\n        id: \"export-data-toast\"\n      });\n      \n      // Fetch all data with server-side sorting\n      const allData = await getAllItems();\n      \n      if (allData.length === 0) {\n        toast.error(\"Export failed\", {\n          description: \"No data available to export.\",\n          id: \"export-data-toast\"\n        });\n        return;\n      }\n      \n      // Get visible columns and apply export\n      const visibleColumns = table.getAllColumns()\n        .filter(column => column.getIsVisible())\n        .filter(column => column.id !== 'actions' && column.id !== 'select');\n      \n      // Generate export headers - always start with visible columns only\n      const visibleColumnIds = visibleColumns.map(column => column.id);\n      // Get all table column IDs (visible + hidden) to identify what's a table column vs transform column\n      const allTableColumnIds = table.getAllColumns()\n        .filter(column => column.id !== 'actions' && column.id !== 'select')\n        .map(column => column.id);\n      \n      let exportHeaders: string[];\n      \n      if (config?.allowExportNewColumns === false) {\n        // Only export visible columns - no new columns from transform\n        exportHeaders = headers && headers.length > 0 \n          ? headers.filter(header => visibleColumnIds.includes(header))\n          : visibleColumnIds;\n      } else {\n        // Allow new columns from transform function, but still filter existing columns by visibility\n        if (headers && headers.length > 0) {\n          // Split headers into existing table columns (must be visible) and new transform columns (allowed)\n          const existingHeaders = headers.filter(header => allTableColumnIds.includes(header) && visibleColumnIds.includes(header));\n          const newHeaders = headers.filter(header => !allTableColumnIds.includes(header));\n          exportHeaders = [...existingHeaders, ...newHeaders];\n        } else {\n          exportHeaders = visibleColumnIds;\n        }\n      }\n      const exportColumnMapping = columnMapping || (() => {\n        const mapping: Record<string, string> = {};\n        \n        // If we have custom headers, generate mapping for them\n        if (headers && headers.length > 0) {\n          headers.forEach(header => {\n            mapping[header] = header\n              .split(/(?=[A-Z])|_/)\n              .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n              .join(' ');\n          });\n        } else {\n          // Otherwise use visible columns\n          visibleColumns.forEach(column => {\n            const headerText = column.columnDef.header as string;\n            \n            if (headerText && typeof headerText === 'string') {\n              mapping[column.id] = headerText;\n            } else {\n              mapping[column.id] = column.id\n                .split(/(?=[A-Z])|_/)\n                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n                .join(' ');\n            }\n          });\n        }\n        \n        return mapping;\n      })();\n      \n      const exportColumnWidths = columnWidths ?\n        exportHeaders.map((_, index) => columnWidths[index] || { wch: 15 }) :\n        exportHeaders.map(() => ({ wch: 15 }));\n      \n      // Update toast for processing\n      toast.loading(\"Processing data...\", {\n        description: \"Generating export file...\",\n        id: \"export-data-toast\"\n      });\n      \n      // Generate timestamp for filename\n      const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n      const filename = `${entityName}-all-pages-export-${timestamp}`;\n      \n      // Export based on type\n      let success = false;\n      if (type === \"csv\") {\n        success = exportToCSV(allData, filename, exportHeaders, exportColumnMapping, transformFunction);\n      } else {\n        success = exportToExcel(\n          allData, \n          filename, \n          exportColumnMapping, \n          exportColumnWidths,\n          exportHeaders,\n          transformFunction\n        );\n      }\n      \n      if (success) {\n        toast.success(\"Export successful\", {\n          description: `Exported all ${allData.length} ${entityName} to ${type.toUpperCase()}.`,\n          id: \"export-data-toast\"\n        });\n      }\n    } catch (error) {\n      console.error(\"Error exporting all pages:\", error);\n      toast.error(\"Export failed\", {\n        description: \"There was a problem exporting all pages. Please try again.\",\n        id: \"export-data-toast\"\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Check if any rows are selected\n  const hasSelection = selectedData && selectedData.length > 0;\n\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button variant=\"outline\" size={size} disabled={isLoading}>\n          {isLoading ? (\n            <>\n              <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n              Exporting...\n            </>\n          ) : (\n            <>\n              <DownloadIcon className=\"mr-2 h-4 w-4\" />\n              Export\n              {hasSelection && <span className=\"ml-1\">({selectedData?.length})</span>}\n            </>\n          )}\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent align=\"end\">\n        {hasSelection ? (\n          <>\n            <DropdownMenuItem onClick={() => handleExport(\"csv\")} disabled={isLoading}>\n              Export Selected as CSV\n            </DropdownMenuItem>\n            <DropdownMenuItem onClick={() => handleExport(\"excel\")} disabled={isLoading}>\n              Export Selected as XLS\n            </DropdownMenuItem>\n          </>\n        ) : (\n          <>\n            <DropdownMenuItem onClick={() => handleExport(\"csv\")} disabled={isLoading}>\n              Export Current Page as CSV\n            </DropdownMenuItem>\n            <DropdownMenuItem onClick={() => handleExport(\"excel\")} disabled={isLoading}>\n              Export Current Page as XLS\n            </DropdownMenuItem>\n            {getAllItems && (\n              <>\n                <DropdownMenuItem \n                  onClick={() => exportAllPages(\"csv\")} \n                  disabled={isLoading}\n                >\n                  Export All Pages as CSV\n                </DropdownMenuItem>\n                <DropdownMenuItem \n                  onClick={() => exportAllPages(\"excel\")} \n                  disabled={isLoading}\n                >\n                  Export All Pages as XLS\n                </DropdownMenuItem>\n              </>\n            )}\n          </>\n        )}\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}"
    },
    {
      "path": "registry/default/components/data-table/data-table-resizer.tsx",
      "type": "registry:component",
      "target": "components/data-table/data-table-resizer.tsx",
      "content": "\"use client\"\n\n// ** import types\nimport type { Header, Table } from \"@tanstack/react-table\"\n\n// ** import core packages\nimport React from \"react\"\nimport { GripVertical } from \"lucide-react\"\n\n// ** import components\nimport { Separator } from \"@/components/ui/separator\"\n\n// ** import utils\nimport { cn } from \"@/lib/utils\"\n\nexport function DataTableResizer<TData>({\n  header,\n  table,\n}: {\n  header: Header<TData, unknown>\n  table: Table<TData>\n}) {\n  const isResizing = header.column.getIsResizing()\n\n  return (\n    <div\n      onMouseDown={header.getResizeHandler()}\n      onTouchStart={header.getResizeHandler()}\n      className={cn(\n        \"absolute right-0 top-0 flex h-full w-4 cursor-col-resize select-none touch-none items-center justify-center\",\n        \"opacity-0 group-hover/th:opacity-100 z-10\",\n        isResizing && \"opacity-100\"\n      )}\n      aria-hidden=\"true\"\n      data-resizing={isResizing ? \"true\" : undefined}\n    >\n      <div className=\"flex h-4/5 items-center justify-center\">\n        <Separator\n          orientation=\"vertical\"\n          decorative={false}\n          className={cn(\n            \"h-4/5 w-0.5 transition-colors duration-200\",\n            isResizing ? \n              \"bg-primary\" : \n              \"bg-border\"\n          )}\n        />\n        \n        {/* Use the GripVertical icon for better visual indication */}\n        <GripVertical \n          className={cn(\n            \"absolute h-4 w-4 text-muted-foreground/70\",\n            isResizing ? \"text-primary\" : \"text-muted-foreground/70\"\n          )}\n          strokeWidth={1.5}\n        />\n      </div>\n    </div>\n  )\n} "
    },
    {
      "path": "registry/default/components/data-table/pagination.tsx",
      "type": "registry:component",
      "target": "components/data-table/pagination.tsx",
      "content": "\"use client\";\n\nimport {\n  ChevronLeftIcon,\n  ChevronRightIcon,\n  DoubleArrowLeftIcon,\n  DoubleArrowRightIcon,\n} from \"@radix-ui/react-icons\";\nimport type { Table } from \"@tanstack/react-table\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\n\nconst getButtonSizeClass = (size: 'sm' | 'default' | 'lg') => {\n  switch (size) {\n    case 'sm': return 'h-7 w-7 p-0';\n    case 'lg': return 'h-11 w-11 p-0';\n    default: return 'h-8 w-8 p-0';\n  }\n};\n\ninterface DataTablePaginationProps<TData> {\n  table: Table<TData>;\n  totalItems?: number; // Total number of items from API\n  totalSelectedItems?: number; // Total selected items across all pages\n  pageSizeOptions?: number[]; // Custom page size options\n  size?: 'sm' | 'default' | 'lg'; // Size prop for components\n}\n\nexport function DataTablePagination<TData>({\n  table,\n  totalItems = 0,\n  totalSelectedItems = 0,\n  pageSizeOptions = [10, 20, 30, 40, 50], // Default options if none provided\n  size = 'default'\n}: DataTablePaginationProps<TData>) {\n  // Convert 'lg' size to 'default' for SelectTrigger since it only accepts 'sm' | 'default'\n  const selectSize = size === 'lg' ? 'default' : size;\n\n  return (\n    <div className=\"flex w-full flex-col items-center justify-between gap-4 overflow-auto px-2 py-1 sm:flex-row sm:gap-8\">\n      <div className=\"flex-1 text-sm text-muted-foreground\">\n        {totalSelectedItems} of {totalItems} row(s) selected.\n      </div>\n      <div className=\"flex flex-col items-center gap-4 sm:flex-row sm:gap-6 lg:gap-8\">\n        <div className=\"flex items-center space-x-2\">\n          <p className=\"whitespace-nowrap text-sm font-medium\">\n            Rows per page\n          </p>\n          <Select\n            value={`${table.getState().pagination.pageSize}`}\n            onValueChange={(value) => {\n              // Validate the input value\n              const numericValue = parseInt(value, 10);\n              if (isNaN(numericValue) || numericValue <= 0) {\n                console.error(`Invalid page size value: ${value}`);\n                return;\n              }\n              \n              try {\n                // Force URL update via direct window manipulation first\n                // This ensures the URL gets updated before the table state changes\n                const url = new URL(window.location.href);\n                url.searchParams.set('pageSize', value);\n                url.searchParams.set('page', '1'); // Always reset to page 1\n                window.history.replaceState({}, '', url.toString());\n                \n                // Then use the table's pagination change handler to update table state\n                // This order ensures the URL is already set when the table state updates\n                table.setPagination({\n                  pageIndex: 0, // Reset to first page\n                  pageSize: numericValue\n                });\n              } catch (error) {\n                console.error('Error updating pagination:', error);\n              }\n            }}\n          >\n            <SelectTrigger className=\"cursor-pointer\" size={selectSize}>\n              <SelectValue placeholder={table.getState().pagination.pageSize} />\n            </SelectTrigger>\n            <SelectContent side=\"top\" className=\"cursor-pointer\">\n              {pageSizeOptions.map((pageSize) => (\n                <SelectItem key={pageSize} value={`${pageSize}`} className=\"cursor-pointer\">\n                  {pageSize}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n        </div>\n        <div className=\"flex items-center justify-center text-sm font-medium\">\n          Page {table.getState().pagination.pageIndex + 1} of{\" \"}\n          {table.getPageCount() || 1}\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <Button\n            aria-label=\"Go to first page\"\n            variant=\"outline\"\n            className={`${getButtonSizeClass(size)} hidden lg:flex cursor-pointer`}\n            onClick={() => table.setPagination({ pageIndex: 0, pageSize: table.getState().pagination.pageSize })}\n            disabled={!table.getCanPreviousPage()}\n          >\n            <DoubleArrowLeftIcon className=\"h-4 w-4\" aria-hidden=\"true\" />\n          </Button>\n          <Button\n            aria-label=\"Go to previous page\"\n            variant=\"outline\"\n            className={`${getButtonSizeClass(size)} cursor-pointer`}\n            onClick={() => table.setPagination({\n              pageIndex: table.getState().pagination.pageIndex - 1,\n              pageSize: table.getState().pagination.pageSize\n            })}\n            disabled={!table.getCanPreviousPage()}\n          >\n            <ChevronLeftIcon className=\"h-4 w-4\" aria-hidden=\"true\" />\n          </Button>\n          <Button\n            aria-label=\"Go to next page\"\n            variant=\"outline\"\n            className={`${getButtonSizeClass(size)} cursor-pointer`}\n            onClick={() => table.setPagination({\n              pageIndex: table.getState().pagination.pageIndex + 1,\n              pageSize: table.getState().pagination.pageSize\n            })}\n            disabled={!table.getCanNextPage()}\n          >\n            <ChevronRightIcon className=\"h-4 w-4\" aria-hidden=\"true\" />\n          </Button>\n          <Button\n            aria-label=\"Go to last page\"\n            variant=\"outline\"\n            className={`${getButtonSizeClass(size)} hidden lg:flex cursor-pointer`}\n            onClick={() => table.setPagination({\n              pageIndex: table.getPageCount() - 1,\n              pageSize: table.getState().pagination.pageSize\n            })}\n            disabled={!table.getCanNextPage()}\n          >\n            <DoubleArrowRightIcon className=\"h-4 w-4\" aria-hidden=\"true\" />\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n}"
    },
    {
      "path": "registry/default/components/data-table/toolbar.tsx",
      "type": "registry:component",
      "target": "components/data-table/toolbar.tsx",
      "content": "\"use client\";\n\nimport { Cross2Icon } from \"@radix-ui/react-icons\";\nimport type { Table } from \"@tanstack/react-table\";\nimport { useEffect, useState, useRef, useCallback } from \"react\";\nimport { usePathname, useRouter, useSearchParams } from \"next/navigation\";\nimport { Settings, Undo2, TrashIcon, EyeOff, CheckSquare, MoveHorizontal } from \"lucide-react\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { CalendarDatePicker } from \"@/components/calendar-date-picker\";\nimport { DataTableViewOptions } from \"./view-options\";\nimport { DataTableExport } from \"./data-export\";\nimport type { DataTransformFunction, ExportableData } from \"./utils/export-utils\";\nimport { resetUrlState } from \"./utils/deep-utils\";\nimport { parseDateFromUrl } from \"./utils/url-state\";\nimport type { TableConfig } from \"./utils/table-config\";\nimport { formatDate } from \"./utils/date-format\";\n\n// Helper functions for component sizing\nconst getInputSizeClass = (size: 'sm' | 'default' | 'lg') => {\n  switch (size) {\n    case 'sm': return 'h-8';\n    case 'lg': return 'h-11';\n    default: return '';\n  }\n};\n\nconst getButtonSizeClass = (size: 'sm' | 'default' | 'lg', isIcon = false) => {\n  if (isIcon) {\n    switch (size) {\n      case 'sm': return 'h-8 w-8';\n      case 'lg': return 'h-11 w-11';\n      default: return '';\n    }\n  }\n  switch (size) {\n    case 'sm': return 'h-8 px-3';\n    case 'lg': return 'h-11 px-5';\n    default: return '';\n  }\n};\n\ninterface DataTableToolbarProps<TData extends ExportableData> {\n  table: Table<TData>;\n  setSearch: (value: string | ((prev: string) => string)) => void;\n  setDateRange: (\n    value:\n      | { from_date: string; to_date: string }\n      | ((prev: { from_date: string; to_date: string }) => {\n        from_date: string;\n        to_date: string;\n      })\n  ) => void;\n  totalSelectedItems?: number;\n  deleteSelection?: () => void;\n  getSelectedItems?: () => Promise<TData[]>;\n  getAllItems?: () => TData[];\n  config: TableConfig;\n  resetColumnSizing?: () => void;\n  resetColumnOrder?: () => void;\n  entityName?: string;\n  columnMapping?: Record<string, string>;\n  columnWidths?: Array<{ wch: number }>;\n  headers?: string[];\n  transformFunction?: DataTransformFunction<TData>;\n  customToolbarComponent?: React.ReactNode;\n}\n\nexport function DataTableToolbar<TData extends ExportableData>({\n  table,\n  setSearch,\n  setDateRange,\n  totalSelectedItems = 0,\n  deleteSelection,\n  getSelectedItems,\n  getAllItems,\n  config,\n  resetColumnSizing,\n  resetColumnOrder,\n  entityName = \"items\",\n  columnMapping,\n  columnWidths,\n  headers,\n  transformFunction,\n  customToolbarComponent,\n}: DataTableToolbarProps<TData>) {\n  // Get router and pathname for URL state reset\n  const router = useRouter();\n  const pathname = usePathname();\n  const searchParams = useSearchParams();\n\n  const tableFiltered = table.getState().columnFilters.length > 0;\n\n  // Get search value directly from URL query parameter\n  const searchParamFromUrl = searchParams.get(\"search\") || \"\";\n  // Decode URL-encoded search parameter\n  const decodedSearchParam = searchParamFromUrl\n    ? decodeURIComponent(searchParamFromUrl)\n    : \"\";\n\n  // Get search value from table state as fallback\n  const currentSearchFromTable =\n    (table.getState().globalFilter as string) || \"\";\n\n  // Initialize local search state with URL value or table state\n  const [localSearch, setLocalSearch] = useState(\n    decodedSearchParam || currentSearchFromTable\n  );\n\n  // Track if the search is being updated locally\n  const isLocallyUpdatingSearch = useRef(false);\n\n  // Update local search when URL param changes\n  useEffect(() => {\n    // Skip if local update is in progress\n    if (isLocallyUpdatingSearch.current) {\n      return;\n    }\n\n    const searchFromUrl = searchParams.get(\"search\") || \"\";\n    const decodedSearchFromUrl = searchFromUrl\n      ? decodeURIComponent(searchFromUrl)\n      : \"\";\n\n    if (decodedSearchFromUrl !== localSearch) {\n      setLocalSearch(decodedSearchFromUrl);\n    }\n  }, [searchParams, localSearch]);\n\n  const tableSearch = (table.getState().globalFilter as string) || \"\";\n  // Also update local search when table globalFilter changes\n  useEffect(() => {\n    // Skip if local update is in progress\n    if (isLocallyUpdatingSearch.current) {\n      return;\n    }\n\n    if (tableSearch !== localSearch && tableSearch !== \"\") {\n      setLocalSearch(tableSearch);\n    }\n  }, [tableSearch, localSearch]);\n\n  // Reference to track if we're currently updating dates\n  const isUpdatingDates = useRef(false);\n  \n  // Reference to track the last set date values to prevent updates with equal values\n  const lastSetDates = useRef<{\n    from: Date | undefined;\n    to: Date | undefined;\n  }>({ from: undefined, to: undefined });\n\n  // Memoize the getInitialDates function to prevent unnecessary recreations\n  const getInitialDates = useCallback((): {\n    from: Date | undefined;\n    to: Date | undefined;\n  } => {\n    // If we're in the middle of an update, don't parse from URL to avoid cycles\n    if (isUpdatingDates.current) {\n      return lastSetDates.current;\n    }\n\n    const dateRangeParam = searchParams.get(\"dateRange\");\n    if (dateRangeParam) {\n      try {\n        const parsed = JSON.parse(dateRangeParam);\n        \n        // Parse dates from URL param\n        const fromDate = parsed?.from_date ? parseDateFromUrl(parsed.from_date) : undefined;\n        const toDate = parsed?.to_date ? parseDateFromUrl(parsed.to_date) : undefined;\n        \n        // Cache these values\n        lastSetDates.current = { from: fromDate, to: toDate };\n        \n        return {\n          from: fromDate,\n          to: toDate,\n        };\n      } catch (e) {\n        console.warn(\"Error parsing dateRange from URL:\", e);\n        return { from: undefined, to: undefined };\n      }\n    }\n    return { from: undefined, to: undefined };\n  }, [searchParams]);\n\n  // Initial state with date values from URL\n  const [dates, setDates] = useState<{\n    from: Date | undefined;\n    to: Date | undefined;\n  }>(getInitialDates());\n\n  // Track if user has explicitly changed dates\n  const [datesModified, setDatesModified] = useState(\n    !!dates.from || !!dates.to\n  );\n\n  // Load initial date range from URL params only once on component mount\n  useEffect(() => {\n    const initialDates = getInitialDates();\n    if (initialDates.from || initialDates.to) {\n      setDates(initialDates);\n      setDatesModified(true);\n    }\n  }, [getInitialDates]); // Include memoized function as dependency\n\n  // Determine if any filters are active\n  const isFiltered = tableFiltered || !!localSearch || datesModified;\n\n  // Create a ref to store the debounce timer\n  const searchDebounceTimerRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Cleanup timers when component unmounts\n  useEffect(() => {\n    return () => {\n      // Clear debounce timer\n      if (searchDebounceTimerRef.current) {\n        clearTimeout(searchDebounceTimerRef.current);\n      }\n    };\n  }, []);\n\n  // Handle search with improved debounce to prevent character loss\n  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n\n    // Mark that search is being updated locally\n    isLocallyUpdatingSearch.current = true;\n    setLocalSearch(value);\n\n    // Clear any existing timer to prevent race conditions\n    if (searchDebounceTimerRef.current) {\n      clearTimeout(searchDebounceTimerRef.current);\n    }\n\n    // Set a new debounce timer to update the actual search state\n    searchDebounceTimerRef.current = setTimeout(() => {\n      // Trim whitespace before sending to backend API\n      const trimmedValue = value.trim();\n      setSearch(trimmedValue);\n      searchDebounceTimerRef.current = null;\n\n      // Reset the local update flag after a short delay\n      // This ensures URL changes don't override the input immediately\n      setTimeout(() => {\n        isLocallyUpdatingSearch.current = false;\n      }, 100);\n    }, 500);\n  };\n\n  // Listen for URL parameter changes and update local state if needed\n  useEffect(() => {\n    // Skip this effect if we're currently updating the dates ourselves\n    if (isUpdatingDates.current) {\n      return;\n    }\n    \n    const newDates = getInitialDates();\n    \n    // Check if dates have actually changed to avoid unnecessary updates\n    const hasFromChanged = \n      (newDates.from && !dates.from) || \n      (!newDates.from && dates.from) || \n      (newDates.from && dates.from && newDates.from.getTime() !== dates.from.getTime());\n      \n    const hasToChanged = \n      (newDates.to && !dates.to) || \n      (!newDates.to && dates.to) || \n      (newDates.to && dates.to && newDates.to.getTime() !== dates.to.getTime());\n    \n    if (hasFromChanged || hasToChanged) {\n      setDates(newDates);\n      setDatesModified(!!(newDates.from || newDates.to));\n    }\n  }, [dates, getInitialDates]);\n\n  // Handle date selection for filtering\n  const handleDateSelect = ({ from, to }: { from: Date; to: Date }) => {\n    // Compare with previous dates to avoid unnecessary updates\n    const hasFromChanged = \n      (from && !dates.from) || \n      (!from && dates.from) || \n      (from && dates.from && from.getTime() !== dates.from.getTime());\n      \n    const hasToChanged = \n      (to && !dates.to) || \n      (!to && dates.to) || \n      (to && dates.to && to.getTime() !== dates.to.getTime());\n    \n    // Only update if dates have actually changed\n    if (!hasFromChanged && !hasToChanged) {\n      return;\n    }\n    \n    // Set flag to prevent update loops\n    isUpdatingDates.current = true;\n    \n    // Update internal state\n    setDates({ from, to });\n    setDatesModified(true);\n    lastSetDates.current = { from, to };\n\n    // Convert dates to strings in YYYY-MM-DD format for the API\n    setDateRange({\n      from_date: from ? formatDate(from) : \"\",\n      to_date: to ? formatDate(to) : \"\",\n    });\n    \n    // Reset the updating flag after a delay\n    setTimeout(() => {\n      isUpdatingDates.current = false;\n    }, 100);\n  };\n\n  // Reset all filters and URL state\n  const handleResetFilters = () => {\n    // Reset table filters\n    table.resetColumnFilters();\n\n    // Reset search\n    setLocalSearch(\"\");\n    setSearch(\"\");\n\n    // Reset dates to undefined (no filter)\n    setDates({\n      from: undefined,\n      to: undefined,\n    });\n    setDatesModified(false);\n    setDateRange({\n      from_date: \"\",\n      to_date: \"\",\n    });\n\n    // Reset URL state by removing all query parameters, but only if URL state is enabled\n    if (config.enableUrlState) {\n      resetUrlState(router, pathname);\n    }\n  };\n\n  // Get selected items data for export - this is now just for the UI indication\n  // The actual data fetching happens in the export component\n  const selectedItems =\n    totalSelectedItems > 0\n      ? new Array(totalSelectedItems).fill({} as TData)\n      : [];\n\n  // Get all available items data for export\n  const allItems = getAllItems ? getAllItems() : [];\n\n  return (\n    <div className=\"flex flex-wrap items-center justify-between\">\n      <div className=\"flex flex-1 flex-wrap items-center gap-2\">\n        {config.enableSearch && (\n          <Input\n            placeholder={config.searchPlaceholder || `Search ${entityName}...`}\n            value={localSearch}\n            onChange={handleSearchChange}\n            className={`w-[150px] lg:w-[250px] ${getInputSizeClass(config.size)}`}\n          />\n        )}\n\n        {config.enableDateFilter && (\n          <div className=\"flex items-center\">\n            <CalendarDatePicker\n              date={{\n                from: dates.from,\n                to: dates.to,\n              }}\n              onDateSelect={handleDateSelect}\n              className={`w-fit cursor-pointer ${getInputSizeClass(config.size)}`}\n              variant=\"outline\"\n            />\n          </div>\n        )}\n\n        {isFiltered && (\n          <Button\n            variant=\"ghost\"\n            onClick={handleResetFilters}\n            className={getButtonSizeClass(config.size)}\n          >\n            Reset\n            <Cross2Icon className=\"ml-2 h-4 w-4\" />\n          </Button>\n        )}\n      </div>\n\n      <div className=\"flex items-center gap-2\">\n        {customToolbarComponent}\n\n        {config.enableExport && (\n          <DataTableExport\n            table={table}\n            data={allItems}\n            selectedData={selectedItems}\n            getSelectedItems={getSelectedItems}\n            entityName={entityName}\n            columnMapping={columnMapping}\n            columnWidths={columnWidths}\n            headers={headers}\n            transformFunction={transformFunction}\n            size={config.size}\n            config={config}\n          />\n        )}\n\n        {config.enableColumnVisibility && (\n          <DataTableViewOptions\n            table={table}\n            columnMapping={columnMapping}\n            size={config.size}\n          />\n        )}\n\n        <Popover>\n          <PopoverTrigger asChild>\n            <Button\n              variant=\"outline\"\n              size=\"icon\"\n              className={getButtonSizeClass(config.size, true)}\n              title=\"Table Settings\"\n            >\n              <Settings className=\"h-4 w-4\" />\n              <span className=\"sr-only\">Open table settings</span>\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent className=\"w-60\" align=\"end\">\n            <div className=\"grid gap-4\">\n              <div className=\"space-y-2\">\n                <h4 className=\"font-medium leading-none\">Table Settings</h4>\n              </div>\n\n              <div className=\"grid gap-2\">\n                {config.enableColumnResizing && resetColumnSizing && (\n                  <Button\n                    variant=\"outline\"\n                    size={config.size}\n                    className=\"justify-start\"\n                    onClick={(e) => {\n                      e.preventDefault();\n                      resetColumnSizing();\n                    }}\n                  >\n                    <Undo2 className=\"mr-2 h-4 w-4\" />\n                    Reset Column Sizes\n                  </Button>\n                )}\n\n                {resetColumnOrder && (\n                  <Button\n                    variant=\"outline\"\n                    size={config.size}\n                    className=\"justify-start\"\n                    onClick={(e) => {\n                      e.preventDefault();\n                      resetColumnOrder();\n                    }}\n                  >\n                    <MoveHorizontal className=\"mr-2 h-4 w-4\" />\n                    Reset Column Order\n                  </Button>\n                )}\n\n                {config.enableRowSelection && (\n                  <Button\n                    variant=\"outline\"\n                    size={config.size}\n                    className=\"justify-start\"\n                    onClick={(e) => {\n                      e.preventDefault();\n                      table.resetRowSelection();\n                      // Also call the parent component's deleteSelection function if available\n                      if (deleteSelection) {\n                        deleteSelection();\n                      }\n                    }}\n                  >\n                    <CheckSquare className=\"mr-2 h-4 w-4\" />\n                    Clear Selection\n                  </Button>\n                )}\n\n                {!table.getIsAllColumnsVisible() && (\n                  <Button\n                    variant=\"outline\"\n                    size={config.size}\n                    className=\"justify-start\"\n                    onClick={() => table.resetColumnVisibility()}\n                  >\n                    <EyeOff className=\"mr-2 h-4 w-4\" />\n                    Show All Columns\n                  </Button>\n                )}\n              </div>\n            </div>\n          </PopoverContent>\n        </Popover>\n      </div>\n    </div>\n  );\n}\n"
    },
    {
      "path": "registry/default/components/data-table/view-options.tsx",
      "type": "registry:component",
      "target": "components/data-table/view-options.tsx",
      "content": "\"use client\";\n\nimport type { Table, Column } from \"@tanstack/react-table\";\nimport { Check, GripVertical, Settings2, RotateCcw } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n  CommandSeparator,\n} from \"@/components/ui/command\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { cn } from \"@/lib/utils\";\nimport * as React from \"react\";\nimport { useCallback, useEffect, useState, useMemo } from \"react\";\n\ninterface DataTableViewOptionsProps<TData> {\n  table: Table<TData>;\n  columnMapping?: Record<string, string>;\n  size?: 'sm' | 'default' | 'lg';\n}\n\n// Local storage key for column order\nconst COLUMN_ORDER_STORAGE_KEY = \"data-table-column-order\";\n\nexport function DataTableViewOptions<TData>({\n  table,\n  columnMapping,\n  size = 'default',\n}: DataTableViewOptionsProps<TData>) {\n  // Get columns that can be hidden\n  const columns = React.useMemo(\n    () =>\n      table\n        .getAllColumns()\n        .filter(\n          (column) =>\n            typeof column.accessorFn !== \"undefined\" && column.getCanHide(),\n        ),\n    [table],\n  );\n\n  // State for drag and drop\n  const [draggedColumnId, setDraggedColumnId] = useState<string | null>(null);\n\n  // Order columns based on the current table column order\n  const columnOrder = table.getState().columnOrder;\n  const orderedColumns = useMemo(() => {\n    if (!columnOrder.length) {\n      return columns;\n    }\n\n    // Create a new array with columns sorted according to the columnOrder\n    return [...columns].sort((a, b) => {\n      const aIndex = columnOrder.indexOf(a.id);\n      const bIndex = columnOrder.indexOf(b.id);\n\n      // If column isn't in the order array, put it at the end\n      if (aIndex === -1) return 1;\n      if (bIndex === -1) return -1;\n\n      return aIndex - bIndex;\n    });\n  }, [columns, columnOrder]);\n\n  // Load column order from localStorage on initial render\n  useEffect(() => {\n    try {\n      const savedOrder = localStorage.getItem(COLUMN_ORDER_STORAGE_KEY);\n      if (savedOrder) {\n        const columnOrder = JSON.parse(savedOrder);\n        // Apply saved column order to the table\n        table.setColumnOrder(columnOrder);\n      }\n    } catch (error) {\n      console.error(\"Error loading column order:\", error);\n    }\n  }, [table]);\n\n  // Save column order to localStorage when it changes\n  const saveColumnOrder = useCallback((columnOrder: string[]) => {\n    try {\n      localStorage.setItem(COLUMN_ORDER_STORAGE_KEY, JSON.stringify(columnOrder));\n    } catch (error) {\n      console.error(\"Error saving column order:\", error);\n    }\n  }, []);\n\n  // Handle column visibility toggle\n  const handleColumnVisibilityToggle = useCallback((columnId: string) => {\n    const currentVisibility = table.getState().columnVisibility;\n    const isCurrentlyVisible = currentVisibility[columnId] !== false;\n    \n    table.setColumnVisibility({\n      ...currentVisibility,\n      [columnId]: !isCurrentlyVisible,\n    });\n  }, [table]);\n\n  // Handle drag start\n  const handleDragStart = useCallback((e: React.DragEvent, columnId: string) => {\n    setDraggedColumnId(columnId);\n    e.dataTransfer.effectAllowed = \"move\";\n    // This helps with dragging visuals\n    if (e.dataTransfer.setDragImage && e.currentTarget instanceof HTMLElement) {\n      e.dataTransfer.setDragImage(e.currentTarget, 20, 20);\n    }\n  }, []);\n\n  // Handle drag over\n  const handleDragOver = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    e.dataTransfer.dropEffect = \"move\";\n  }, []);\n\n  // Handle drop\n  const handleDrop = useCallback((e: React.DragEvent, targetColumnId: string) => {\n    e.preventDefault();\n\n    if (!draggedColumnId || draggedColumnId === targetColumnId) return;\n\n    // Get current column order\n    const currentOrder = table.getState().columnOrder.length > 0\n      ? [...table.getState().columnOrder]\n      : table.getAllLeafColumns().map(d => d.id);\n\n    // Find indices\n    const draggedIndex = currentOrder.indexOf(draggedColumnId);\n    const targetIndex = currentOrder.indexOf(targetColumnId);\n\n    if (draggedIndex === -1 || targetIndex === -1) return;\n\n    // Create new order by moving the dragged column\n    const newOrder = [...currentOrder];\n    newOrder.splice(draggedIndex, 1);\n    newOrder.splice(targetIndex, 0, draggedColumnId);\n\n    // Update table column order\n    table.setColumnOrder(newOrder);\n\n    // Save to localStorage\n    saveColumnOrder(newOrder);\n\n    setDraggedColumnId(null);\n  }, [draggedColumnId, table, saveColumnOrder]);\n\n  // Reset column order\n  const resetColumnOrder = useCallback(() => {\n    // Clear order by setting empty array (table will use default order)\n    table.setColumnOrder([]);\n    // Remove from localStorage\n    localStorage.removeItem(COLUMN_ORDER_STORAGE_KEY);\n  }, [table]);\n\n  // Get column display label\n  const getColumnLabel = useCallback((column: Column<TData, unknown>) => {\n    // First check if we have a mapping for this column\n    if (columnMapping && column.id in columnMapping) {\n      return columnMapping[column.id];\n    }\n    // Then check for meta label\n    return (column.columnDef.meta as { label?: string })?.label ??\n      // Finally fall back to formatted column ID\n      column.id.replace(/_/g, ' ');\n  }, [columnMapping]);\n\n  return (\n    <Popover>\n      <PopoverTrigger asChild>\n        <Button\n          aria-label=\"Toggle columns\"\n          variant=\"outline\" \n          size={size}\n          className=\"ml-auto hidden lg:flex\"\n        >\n          <Settings2 className=\"mr-2 h-4 w-4\" />\n          View\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent align=\"end\" className=\"w-[220px] p-0\">\n        <Command>\n          <CommandInput placeholder=\"Search columns...\" />\n          <CommandList>\n            <CommandEmpty>No columns found.</CommandEmpty>\n            <CommandGroup>\n              {orderedColumns.map((column) => (\n                <CommandItem\n                  key={column.id}\n                  onSelect={() => handleColumnVisibilityToggle(column.id)}\n                  draggable\n                  onDragStart={(e) => handleDragStart(e, column.id)}\n                  onDragOver={handleDragOver}\n                  onDrop={(e) => handleDrop(e, column.id)}\n                  className={cn(\n                    \"flex items-center cursor-grab\",\n                    draggedColumnId === column.id && \"bg-accent opacity-50\"\n                  )}\n                >\n                  <GripVertical className=\"mr-2 h-4 w-4 cursor-grab\" />\n                  <span className=\"flex-grow truncate capitalize\">\n                    {getColumnLabel(column)}\n                  </span>\n                  <Check\n                    className={cn(\n                      \"ml-auto h-4 w-4\",\n                      column.getIsVisible() ? \"opacity-100\" : \"opacity-0\",\n                    )}\n                  />\n                </CommandItem>\n              ))}\n            </CommandGroup>\n            <CommandSeparator />\n            <CommandGroup>\n              <CommandItem\n                onSelect={resetColumnOrder}\n                className=\"justify-center text-center cursor-pointer\"\n              >\n                <RotateCcw className=\"mr-2 h-4 w-4\" />\n                Reset Column Order\n              </CommandItem>\n            </CommandGroup>\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  );\n}\n"
    },
    {
      "path": "registry/default/components/data-table/hooks/use-table-column-resize.ts",
      "type": "registry:hook",
      "target": "components/data-table/hooks/use-table-column-resize.ts",
      "content": "\"use client\";\n\nimport { useState, useEffect, useCallback, useRef } from \"react\";\nimport { ColumnSizingState } from \"@tanstack/react-table\";\n\n// Debounce function to limit expensive operations\nfunction useDebounce<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\n/**\n * Custom hook to manage table column sizing with localStorage persistence\n * and optimized performance\n * \n * @param tableId Unique identifier for the table\n * @param enableResizing Whether column resizing is enabled\n * @returns An object with column sizing state and setter\n */\nexport function useTableColumnResize(\n  tableId: string,\n  enableResizing: boolean = false\n) {\n  // Column sizing state\n  const [columnSizing, setColumnSizing] = useState<ColumnSizingState>({});\n  \n  // Track if initial load from localStorage is complete\n  const initialLoadComplete = useRef(false);\n\n  // Track if sizes have been changed by user (to avoid overwriting on initial load)\n  const userChangedSizes = useRef(false);\n  \n  // Track the previous state to detect actual changes\n  const prevSizingRef = useRef<ColumnSizingState>({});\n  \n  // Debounce the columnSizing for localStorage operations to improve performance\n  const debouncedColumnSizing = useDebounce(columnSizing, 300);\n\n  // Custom setter that marks user changes\n  const handleSetColumnSizing = useCallback((newSizing: ColumnSizingState | ((prev: ColumnSizingState) => ColumnSizingState)) => {\n    setColumnSizing(prev => {\n      const nextState = typeof newSizing === 'function' ? newSizing(prev) : newSizing;\n      \n      // Check if this is a real user change and not just the initial load\n      if (initialLoadComplete.current && \n          JSON.stringify(nextState) !== JSON.stringify(prevSizingRef.current)) {\n        userChangedSizes.current = true;\n        prevSizingRef.current = nextState;\n      }\n      \n      return nextState;\n    });\n  }, []);\n\n  // Load saved column sizes from localStorage on mount\n  useEffect(() => {\n    if (enableResizing && !initialLoadComplete.current) {\n      try {\n        const savedSizing = localStorage.getItem(`table-column-sizing-${tableId}`);\n        if (savedSizing) {\n          const parsed = JSON.parse(savedSizing);\n          setColumnSizing(parsed);\n          prevSizingRef.current = parsed;\n        }\n      } catch (error) {\n        console.warn('Failed to load saved column sizing from localStorage:', error);\n      } finally {\n        initialLoadComplete.current = true;\n      }\n    }\n  }, [tableId, enableResizing]);\n\n  // Save column sizes to localStorage when they change (debounced)\n  useEffect(() => {\n    if (enableResizing && initialLoadComplete.current && userChangedSizes.current) {\n      try {\n        localStorage.setItem(`table-column-sizing-${tableId}`, JSON.stringify(debouncedColumnSizing));\n      } catch (error) {\n        console.warn('Failed to save column sizing to localStorage:', error);\n      }\n    }\n  }, [debouncedColumnSizing, tableId, enableResizing]);\n\n  // Memoized function to reset column sizes\n  const resetColumnSizing = useCallback(() => {\n    setColumnSizing({});\n    userChangedSizes.current = true;\n    prevSizingRef.current = {};\n\n    if (enableResizing) {\n      try {\n        localStorage.removeItem(`table-column-sizing-${tableId}`);\n      } catch (error) {\n        console.warn('Failed to remove column sizing from localStorage:', error);\n      }\n    }\n  }, [enableResizing, tableId]);\n\n  return {\n    columnSizing,\n    setColumnSizing: handleSetColumnSizing,\n    resetColumnSizing,\n  };\n} "
    },
    {
      "path": "registry/default/components/data-table/utils/case-utils.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/case-utils.ts",
      "content": "/**\n * Utility functions for case conversion in table keys\n */\n\nexport type CaseFormat = 'snake_case' | 'camelCase' | 'PascalCase' | 'kebab-case';\n\n/**\n * Convert a string to snake_case\n */\nexport function toSnakeCase(str: string): string {\n  return str\n    .replace(/([A-Z])/g, '_$1')\n    .replace(/[-\\s]/g, '_')\n    .toLowerCase()\n    .replace(/^_/, '');\n}\n\n/**\n * Convert a string to camelCase\n */\nexport function toCamelCase(str: string): string {\n  return str\n    .toLowerCase()\n    .replace(/[-_\\s](.)/g, (_, char) => char.toUpperCase());\n}\n\n/**\n * Convert a string to PascalCase\n */\nexport function toPascalCase(str: string): string {\n  const camelCase = toCamelCase(str);\n  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n}\n\n/**\n * Convert a string to kebab-case\n */\nexport function toKebabCase(str: string): string {\n  return str\n    .replace(/([A-Z])/g, '-$1')\n    .replace(/[_\\s]/g, '-')\n    .toLowerCase()\n    .replace(/^-/, '');\n}\n\n/**\n * Convert a string to the specified case format\n */\nexport function convertCase(str: string, format: CaseFormat): string {\n  switch (format) {\n    case 'snake_case':\n      return toSnakeCase(str);\n    case 'camelCase':\n      return toCamelCase(str);\n    case 'PascalCase':\n      return toPascalCase(str);\n    case 'kebab-case':\n      return toKebabCase(str);\n    default:\n      return str;\n  }\n}\n\n/**\n * Type for converted object keys\n */\ntype ConvertedKeys<T extends Record<string, unknown>> = {\n  [K in keyof T as K extends string ? string : never]: T[K];\n};\n\n/**\n * Convert all keys in an object to the specified case format\n */\nexport function convertObjectKeys<T extends Record<string, unknown>>(\n  obj: T,\n  format: CaseFormat\n): ConvertedKeys<T> {\n  const result: Record<string, unknown> = {};\n\n  Object.entries(obj).forEach(([key, value]) => {\n    const newKey = convertCase(key, format);\n    result[newKey] = value;\n  });\n\n  return result as ConvertedKeys<T>;\n}\n\n/**\n * Type for custom key mapping function\n */\nexport type KeyMappingFunction = (key: string) => string;\n\n/**\n * Convert object keys using a custom mapping function\n */\nexport function convertObjectKeysWithMapper<T extends Record<string, unknown>>(\n  obj: T,\n  mapper: KeyMappingFunction\n): ConvertedKeys<T> {\n  const result: Record<string, unknown> = {};\n\n  Object.entries(obj).forEach(([key, value]) => {\n    const newKey = mapper(key);\n    result[newKey] = value;\n  });\n\n  return result as ConvertedKeys<T>;\n}\n\n/**\n * Configuration interface for case formatting\n */\nexport interface CaseFormatConfig {\n  /** Format for URL parameters */\n  urlFormat?: CaseFormat;\n  /** Format for API parameters */\n  apiFormat?: CaseFormat;\n  /** Custom key mapping function (overrides format settings) */\n  keyMapper?: KeyMappingFunction;\n}\n\n/**\n * Default case format configuration\n */\nexport const DEFAULT_CASE_CONFIG: Required<CaseFormatConfig> = {\n  urlFormat: 'camelCase',\n  apiFormat: 'snake_case',\n  keyMapper: (key: string) => key, // No transformation by default\n};"
    },
    {
      "path": "registry/default/components/data-table/utils/column-sizing.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/column-sizing.ts",
      "content": "// ** import types\nimport type { ColumnDef } from \"@tanstack/react-table\";\n\n/**\n * Type guard to check if column has id and size\n */\nfunction hasIdAndSize<TData>(\n  column: ColumnDef<TData, unknown>\n): column is ColumnDef<TData, unknown> & { id: string; size: number } {\n  return (\n    'id' in column &&\n    typeof column.id === 'string' &&\n    'size' in column &&\n    typeof column.size === 'number'\n  );\n}\n\n/**\n * Type guard to check if column has accessorKey and size\n */\nfunction hasAccessorKeyAndSize<TData>(\n  column: ColumnDef<TData, unknown>\n): column is ColumnDef<TData, unknown> & { accessorKey: string; size: number } {\n  return (\n    'accessorKey' in column &&\n    typeof column.accessorKey === 'string' &&\n    'size' in column &&\n    typeof column.size === 'number'\n  );\n}\n\n/**\n * Extract default column sizes from column definitions\n */\nexport function extractDefaultColumnSizes<TData>(\n  columns: ColumnDef<TData, unknown>[]\n): Record<string, number> {\n  const defaultSizing: Record<string, number> = {};\n\n  columns.forEach((column) => {\n    if (hasIdAndSize(column)) {\n      defaultSizing[column.id] = column.size;\n    } else if (hasAccessorKeyAndSize(column)) {\n      defaultSizing[column.accessorKey] = column.size;\n    }\n  });\n\n  return defaultSizing;\n}\n\n/**\n * Validate parsed column sizing object\n */\nfunction isValidColumnSizing(value: unknown): value is Record<string, number> {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  return Object.values(value as Record<string, unknown>).every(\n    (size) =>\n      typeof size === 'number' && !Number.isNaN(size) && size > 0\n  );\n}\n\n/**\n * Initialize column sizes from localStorage or defaults\n */\nexport function initializeColumnSizes<TData>(\n  columns: ColumnDef<TData, unknown>[],\n  tableId: string,\n  setColumnSizing: (sizes: Record<string, number>) => void\n): void {\n  // Only proceed if we have columns to work with\n  if (columns.length === 0) return;\n\n  // Extract default sizes from column definitions\n  const defaultSizing = extractDefaultColumnSizes(columns);\n\n  // Only set if we have sizes to apply\n  if (Object.keys(defaultSizing).length === 0) return;\n\n  // Check localStorage first\n  try {\n    const savedSizing = localStorage.getItem(`table-column-sizing-${tableId}`);\n    if (!savedSizing) {\n      // Only apply defaults if no saved sizing exists\n      setColumnSizing(defaultSizing);\n    } else {\n      // Parse saved sizing\n      const parsedSizing = JSON.parse(savedSizing);\n\n      // Validate the parsed sizing\n      if (isValidColumnSizing(parsedSizing)) {\n        setColumnSizing(parsedSizing);\n      } else {\n        console.warn('Invalid column sizing format in localStorage, using defaults');\n        setColumnSizing(defaultSizing);\n      }\n    }\n  } catch (error) {\n    // If localStorage fails, apply defaults\n    console.warn('Failed to load saved column sizes. Using defaults.', error);\n    setColumnSizing(defaultSizing);\n  }\n}\n\n/**\n * Track column resizing state in document body for styling purposes\n */\nexport function trackColumnResizing(\n  isResizing: boolean,\n  attribute = 'data-resizing'\n): void {\n  if (isResizing) {\n    document.body.setAttribute(attribute, 'true');\n  } else {\n    document.body.removeAttribute(attribute);\n  }\n}\n\n/**\n * Clean up column resizing tracking when component unmounts\n */\nexport function cleanupColumnResizing(\n  attribute = 'data-resizing'\n): void {\n  document.body.removeAttribute(attribute);\n} "
    },
    {
      "path": "registry/default/components/data-table/utils/conditional-state.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/conditional-state.ts",
      "content": "import { useState, useMemo, useCallback } from \"react\";\nimport { useUrlState } from \"./url-state\";\n\n/**\n * Type for the setState function that might return a Promise\n */\ntype SetStateWithPromise<T> = (value: T | ((prevValue: T) => T)) => Promise<URLSearchParams> | undefined;\n\n/**\n * Creates a state hook that can conditionally use URL state or regular React state\n * based on a configuration flag\n * \n * @param enableUrlState - Whether to use URL state (true) or regular React state (false)\n * @returns A hook function that behaves like useState but with conditional URL persistence\n */\nexport function createConditionalStateHook(enableUrlState: boolean) {\n  return function useConditionalState<T>(\n    key: string, \n    defaultValue: T, \n    options = {}\n  ): readonly [T, SetStateWithPromise<T>] {\n    // Always call both hooks to satisfy React hooks rules\n    const [regularState, setRegularState] = useState<T>(defaultValue);\n    const [urlState, setUrlState] = useUrlState<T>(key, defaultValue, options);\n    \n    // Create a compatible setState function for regular state that matches the SetStateWithPromise signature\n    const setRegularStateWrapper = useCallback((valueOrUpdater: T | ((prevValue: T) => T)) => {\n      setRegularState(valueOrUpdater);\n      return undefined; // Return undefined instead of void to match the type\n    }, []);\n    \n    // Return the appropriate state and setter based on config\n    return useMemo(() => {\n      if (enableUrlState) {\n        return [urlState, setUrlState] as const;\n      }\n      \n      return [regularState, setRegularStateWrapper] as const;\n    }, [enableUrlState, regularState, urlState, setUrlState, setRegularStateWrapper]);\n  };\n} "
    },
    {
      "path": "registry/default/components/data-table/utils/date-format.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/date-format.ts",
      "content": "/**\n * Format date to YYYY-MM-DD\n */\nexport function formatDate(date: Date): string {\n  // Use local date components instead of UTC conversion\n  const year = date.getFullYear();\n  const month = String(date.getMonth() + 1).padStart(2, '0'); // getMonth() is 0-based\n  const day = String(date.getDate()).padStart(2, '0');\n  \n  const result = `${year}-${month}-${day}`;\n  \n  return result;\n}"
    },
    {
      "path": "registry/default/components/data-table/utils/deep-utils.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/deep-utils.ts",
      "content": "type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;\n\n// Define a type for comparing values that can handle most common types\ntype Comparable = string | number | boolean | object | null | undefined | TypedArray | Date | RegExp | Set<unknown> | Map<unknown, unknown>;\n\n// Simple LRU cache for frequent comparisons\nclass ComparisonCache {\n  private cache = new Map<string, boolean>();\n  private readonly maxSize = 100;\n\n  getCacheKey(a: Comparable, b: Comparable): string | null {\n    // Only cache for primitive values to avoid memory leaks\n    if (typeof a !== 'object' && typeof b !== 'object' && a !== null && b !== null) {\n      return `${typeof a}:${String(a)}|${typeof b}:${String(b)}`;\n    }\n    return null;\n  }\n\n  get(key: string): boolean | undefined {\n    const value = this.cache.get(key);\n    if (value !== undefined) {\n      // Move to end to mark as recently used\n      this.cache.delete(key);\n      this.cache.set(key, value);\n    }\n    return value;\n  }\n\n  set(key: string, value: boolean): void {\n    if (this.cache.size >= this.maxSize) {\n      // Remove oldest entry\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey !== undefined) {\n        this.cache.delete(firstKey);\n      }\n    }\n    this.cache.set(key, value);\n  }\n}\n\nconst comparisonCache = new ComparisonCache();\n\n/**\n * Optimized deep equality check for objects and arrays\n * @param a First value to compare\n * @param b Second value to compare\n * @returns Boolean indicating if values are deeply equal\n */\nexport function isDeepEqual(a: Comparable, b: Comparable): boolean {\n  // Check cache for primitive values first\n  const cacheKey = comparisonCache.getCacheKey(a, b);\n  if (cacheKey) {\n    const cached = comparisonCache.get(cacheKey);\n    if (cached !== undefined) {\n      return cached;\n    }\n  }\n\n  // Use a WeakMap to track object pairs we've compared to handle circular references\n  const visited = new WeakMap<object, object>();\n  \n  const result = compare(a, b);\n  \n  // Cache the result for primitive values\n  if (cacheKey) {\n    comparisonCache.set(cacheKey, result);\n  }\n  \n  return result;\n  \n  function compare(a: Comparable, b: Comparable): boolean {\n    // Fast path for primitives and identical references\n    if (a === b) return true;\n    \n    // Handle null/undefined\n    if (a == null || b == null) return a === b;\n    \n    // Handle different types quickly\n    const typeA = typeof a;\n    const typeB = typeof b;\n    if (typeA !== typeB) return false;\n    \n    // Fast non-recursive paths for common types\n    if (typeA !== 'object') return false; // We already checked a === b for primitives\n\n    // Handle special object types\n    if (a instanceof Date) {\n      return b instanceof Date && a.getTime() === b.getTime();\n    }\n    \n    if (a instanceof RegExp) {\n      return b instanceof RegExp && a.toString() === b.toString();\n    }\n    \n    // Handle arrays more efficiently\n    if (Array.isArray(a)) {\n      if (!Array.isArray(b) || a.length !== b.length) return false;\n\n      // For small arrays, use direct comparison\n      if (a.length < 20) {\n        for (let i = 0; i < a.length; i++) {\n          if (!compare(a[i] as Comparable, b[i] as Comparable)) return false;\n        }\n        return true;\n      }\n\n      // For larger arrays, check if they contain only primitives\n      const hasPrimitiveValues = a.every(item => typeof item !== 'object' || item === null);\n\n      if (hasPrimitiveValues) {\n        // Only sort arrays containing primitives\n        const sortedA = [...a].sort();\n        const sortedB = [...b].sort();\n\n        // Quick comparison of primitives\n        for (let i = 0; i < sortedA.length; i++) {\n          if (sortedA[i] !== sortedB[i]) return false;\n        }\n      }\n\n      // Compare actual positions for all arrays\n      for (let i = 0; i < a.length; i++) {\n        if (!compare(a[i] as Comparable, b[i] as Comparable)) return false;\n      }\n\n      return true;\n    }\n    \n    // Special handling for Set\n    if (a instanceof Set) {\n      if (!(b instanceof Set) || a.size !== b.size) return false;\n      \n      // Convert to arrays and compare\n      return compare([...a] as Comparable, [...b] as Comparable);\n    }\n    \n    // Special handling for Map\n    if (a instanceof Map) {\n      if (!(b instanceof Map) || a.size !== b.size) return false;\n      \n      for (const [key, val] of a.entries()) {\n        if (!b.has(key) || !compare(val as Comparable, b.get(key) as Comparable)) return false;\n      }\n      \n      return true;\n    }\n    \n    // Handle typed arrays\n    if (ArrayBuffer.isView(a)) {\n      if (!ArrayBuffer.isView(b) || (a as TypedArray).length !== (b as TypedArray).length) return false;\n\n      // Use fast native comparison for TypedArrays\n      if (a instanceof Uint8Array && b instanceof Uint8Array) {\n        for (let i = 0; i < a.length; i++) {\n          if (a[i] !== b[i]) return false;\n        }\n        return true;\n      }\n      \n      // For other typed arrays\n      return compare(Array.from(a as TypedArray), Array.from(b as TypedArray));\n    }\n    \n    // Handle plain objects with circular reference detection\n    if (a.constructor === Object && b.constructor === Object) {\n      // Check for circular references\n      if (visited.has(a as object)) {\n        return visited.get(a as object) === b;\n      }\n      \n      visited.set(a as object, b as object);\n      \n      const keysA = Object.keys(a);\n      const keysB = Object.keys(b);\n      \n      // Quick length check\n      if (keysA.length !== keysB.length) return false;\n      \n      // Sort keys for faster comparison\n      keysA.sort();\n      keysB.sort();\n      \n      // Compare keys first (much faster than comparing values)\n      for (let i = 0; i < keysA.length; i++) {\n        if (keysA[i] !== keysB[i]) return false;\n      }\n      \n      // Compare values\n      for (const key of keysA) {\n        if (!compare((a as Record<string, unknown>)[key] as Comparable, (b as Record<string, unknown>)[key] as Comparable)) return false;\n      }\n      \n      return true;\n    }\n    \n    // If we get here, we're dealing with different object types or custom classes\n    // First check if the objects have the same constructor\n    if (a.constructor !== b.constructor) return false;\n    \n    // For custom classes, fall back to comparing properties\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n    \n    if (keysA.length !== keysB.length) return false;\n\n    for (const key of keysA) {\n      if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n      if (!compare((a as Record<string, unknown>)[key] as Comparable, (b as Record<string, unknown>)[key] as Comparable)) return false;\n    }\n    \n    return true;\n  }\n}\n\n/**\n * Memoizes the result of a function based on its arguments\n * This helps prevent redundant expensive operations\n */\nexport function memoize<T>(fn: (...args: unknown[]) => T): (...args: unknown[]) => T {\n  const cache = new Map<string, T>();\n  \n  return (...args: unknown[]): T => {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      const cachedValue = cache.get(key);\n      return cachedValue !== undefined ? cachedValue : fn(...args);\n    }\n    \n    const result = fn(...args);\n    cache.set(key, result);\n    \n    return result;\n  };\n}\n\n/**\n * Creates a debounced function that delays invoking func until after wait milliseconds\n * @param func The function to debounce\n * @param wait The number of milliseconds to delay\n */\nexport function debounce<T extends (...args: unknown[]) => unknown>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | null = null;\n\n  return (...args: Parameters<T>) => {\n    const later = () => {\n      timeout = null;\n      func(...args);\n    };\n    \n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n/**\n * Reset URL parameters by removing all query parameters\n * @param router Next.js router instance\n * @param pathname Current pathname\n */\nexport function resetUrlState(router: { replace: (path: string) => void }, pathname: string): void {\n  router.replace(pathname);\n}"
    },
    {
      "path": "registry/default/components/data-table/utils/export-utils.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/export-utils.ts",
      "content": "import { toast } from \"sonner\";\nimport * as XLSX from \"xlsx\";\n\n\n// Generic type for exportable data - should have string keys and values that can be converted to string\nexport type ExportableData = Record<string, string | number | boolean | null | undefined>;\n\n// Type for transformation function that developers can provide\nexport type DataTransformFunction<T extends ExportableData> = (row: T) => ExportableData;\n\n/**\n * Convert array of objects to CSV string\n */\nfunction convertToCSV<T extends ExportableData>(\n  data: T[], \n  headers: string[], \n  columnMapping?: Record<string, string>,\n  transformFunction?: DataTransformFunction<T>\n): string {\n  if (data.length === 0) {\n    throw new Error(\"No data to export\");\n  }\n\n  // Create CSV header row with column mapping if provided\n  let csvContent = \"\";\n\n  if (columnMapping) {\n    // Use column mapping for header names\n    const headerRow = headers.map(header => {\n      const mappedHeader = columnMapping[header] || header;\n      // Escape quotes and wrap in quotes if contains comma\n      return mappedHeader.includes(\",\") || mappedHeader.includes('\"')\n        ? `\"${mappedHeader.replace(/\"/g, '\"\"')}\"`\n        : mappedHeader;\n    });\n    csvContent = `${headerRow.join(\",\")}\\n`;\n  } else {\n    // Use original headers\n    csvContent = `${headers.join(\",\")}\\n`;\n  }\n\n  // Add data rows\n  for (const item of data) {\n    // Apply transformation function if provided\n    const transformedItem = transformFunction ? transformFunction(item) : item;\n    \n    const row = headers.map(header => {\n      // Get the value for this header from the transformed item\n      const value = transformedItem[header];\n\n      // Convert all values to string and properly escape for CSV\n      const cellValue = value === null || value === undefined ? \"\" : String(value);\n      // Escape quotes and wrap in quotes if contains comma\n      const escapedValue = cellValue.includes(\",\") || cellValue.includes('\"')\n        ? `\"${cellValue.replace(/\"/g, '\"\"')}\"`\n        : cellValue;\n\n      return escapedValue;\n    });\n\n    csvContent += `${row.join(\",\")}\\n`;\n  }\n\n  return csvContent;\n}\n\n/**\n * Download blob as file\n */\nfunction downloadFile(blob: Blob, filename: string) {\n  const link = document.createElement(\"a\");\n  const url = URL.createObjectURL(blob);\n\n  link.setAttribute(\"href\", url);\n  link.setAttribute(\"download\", filename);\n  link.style.visibility = \"hidden\";\n\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n}\n\n/**\n * Export data to CSV file\n */\nexport function exportToCSV<T extends ExportableData>(\n  data: T[],\n  filename: string,\n  headers: string[] = Object.keys(data[0] || {}),\n  columnMapping?: Record<string, string>,\n  transformFunction?: DataTransformFunction<T>\n): boolean {\n  if (data.length === 0) {\n    console.error(\"No data to export\");\n    return false;\n  }\n\n  try {\n    // Apply transformation function first if provided, then filter data to only include specified headers\n    const processedData = data.map(item => {\n      // Apply transformation function if provided\n      const transformedItem = transformFunction ? transformFunction(item) : item;\n      \n      // Filter to only include specified headers\n      const filteredItem: ExportableData = {};\n      for (const header of headers) {\n        if (header in transformedItem) {\n          filteredItem[header] = transformedItem[header];\n        }\n      }\n      return filteredItem;\n    });\n\n    const csvContent = convertToCSV(processedData, headers, columnMapping);\n    const blob = new Blob([csvContent], { type: \"text/csv;charset=utf-8;\" });\n    downloadFile(blob, `${filename}.csv`);\n    return true;\n  } catch (error) {\n    console.error(\"Error creating CSV:\", error);\n    return false;\n  }\n}\n\n/**\n * Export data to Excel file using xlsx package\n */\nexport function exportToExcel<T extends ExportableData>(\n  data: T[],\n  filename: string,\n  columnMapping?: Record<string, string>,\n  columnWidths?: Array<{ wch: number }>,\n  headers?: string[],\n  transformFunction?: DataTransformFunction<T>\n): boolean {\n  if (data.length === 0) {\n    console.error(\"No data to export\");\n    return false;\n  }\n\n  try {\n    // If no column mapping is provided, create one from the data keys\n    const mapping = columnMapping ||\n      Object.keys(data[0] || {}).reduce((acc, key) => {\n        acc[key] = key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' ');\n        return acc;\n      }, {} as Record<string, string>);\n\n    // Apply transformation function first if provided, then map data to worksheet format\n    const worksheetData = data.map(item => {\n      // Apply transformation function if provided\n      const transformedItem = transformFunction ? transformFunction(item) : item;\n      \n      const row: ExportableData = {};\n      // If headers are provided, only include those columns\n      const columnsToExport = headers || Object.keys(mapping);\n      for (const key of columnsToExport) {\n        if (key in transformedItem) {\n          row[mapping[key]] = transformedItem[key];\n        }\n      }\n      return row;\n    });\n\n    // Create a worksheet\n    const worksheet = XLSX.utils.json_to_sheet(worksheetData);\n\n    // Set column widths if provided\n    if (columnWidths) {\n      worksheet[\"!cols\"] = columnWidths;\n    }\n\n    // Create a workbook\n    const workbook = XLSX.utils.book_new();\n    XLSX.utils.book_append_sheet(workbook, worksheet, \"Data\");\n\n    // Generate Excel file\n    const excelBuffer = XLSX.write(workbook, {\n      bookType: \"xlsx\",\n      type: \"array\"\n    });\n\n    // Create blob and download\n    const blob = new Blob([excelBuffer], {\n      type: \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n    });\n\n    downloadFile(blob, `${filename}.xlsx`);\n    return true;\n  } catch (error) {\n    console.error(\"Error creating Excel file:\", error);\n    return false;\n  }\n}\n\n/**\n * Unified export function that handles loading states and error handling\n */\nexport async function exportData<T extends ExportableData>(\n  type: \"csv\" | \"excel\",\n  getData: () => Promise<T[]>,\n  onLoadingStart?: () => void,\n  onLoadingEnd?: () => void,\n  options?: {\n    headers?: string[];\n    columnMapping?: Record<string, string>;\n    columnWidths?: Array<{ wch: number }>;\n    entityName?: string;\n    transformFunction?: DataTransformFunction<T>;\n  }\n): Promise<boolean> {\n  // Use a consistent toast ID to ensure only one toast is shown at a time\n  const TOAST_ID = \"export-data-toast\";\n  \n  try {\n    // Start loading\n    if (onLoadingStart) onLoadingStart();\n\n    // Show toast for long operations using consistent ID\n    toast.loading(\"Preparing export...\", {\n      description: \"Fetching data for export...\",\n      id: TOAST_ID\n    });\n\n    // Get the data\n    const exportData = await getData();\n\n    // Update the same toast for processing\n    toast.loading(\"Processing data...\", {\n      description: \"Generating export file...\",\n      id: TOAST_ID\n    });\n\n    if (exportData.length === 0) {\n      toast.error(\"Export failed\", {\n        description: \"No data available to export.\",\n        id: TOAST_ID\n      });\n      return false;\n    }\n\n    // Get entity name for display in notifications\n    const entityName = options?.entityName || \"items\";\n\n    // Generate timestamp for filename\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n    const filename = `${entityName}-export-${timestamp}`;\n\n    // Export based on type\n    let success = false;\n    if (type === \"csv\") {\n      success = exportToCSV(\n        exportData, \n        filename, \n        options?.headers, \n        options?.columnMapping,\n        options?.transformFunction\n      );\n      if (success) {\n        toast.success(\"Export successful\", {\n          description: `Exported ${exportData.length} ${entityName} to CSV.`,\n          id: TOAST_ID\n        });\n      }\n    } else {\n      success = exportToExcel(\n        exportData,\n        filename,\n        options?.columnMapping,\n        options?.columnWidths,\n        options?.headers,\n        options?.transformFunction\n      );\n      if (success) {\n        toast.success(\"Export successful\", {\n          description: `Exported ${exportData.length} ${entityName} to Excel.`,\n          id: TOAST_ID\n        });\n      }\n    }\n\n    return success;\n  } catch (error) {\n    console.error(\"Error exporting data:\", error);\n    \n    toast.error(\"Export failed\", {\n      description: \"There was a problem exporting the data. Please try again.\",\n      id: TOAST_ID\n    });\n    return false;\n  } finally {\n    // End loading regardless of result\n    if (onLoadingEnd) onLoadingEnd();\n  }\n}\n"
    },
    {
      "path": "registry/default/components/data-table/utils/index.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/index.ts",
      "content": "// Re-export all utilities for easier imports\nexport * from './column-sizing';\nexport * from './conditional-state';\nexport * from './date-format';\nexport * from './export-utils';\nexport * from './keyboard-navigation';\nexport * from './search';\nexport * from './table-state-handlers';\nexport * from './url-state';\nexport * from './table-config';\nexport * from './deep-utils';\n"
    },
    {
      "path": "registry/default/components/data-table/utils/keyboard-navigation.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/keyboard-navigation.ts",
      "content": "import type { Table } from \"@tanstack/react-table\";\nimport type { KeyboardEvent } from \"react\";\n\n/**\n * Creates a keyboard navigation handler for data tables\n * \n * Supports:\n * - Space to toggle selection\n * - Enter to activate/view a row\n */\nexport function createKeyboardNavigationHandler<TData>(\n  table: Table<TData>,\n  onRowActivate?: (row: TData, rowIndex: number) => void\n) {\n  return (e: KeyboardEvent) => {\n    // If the key is Space or Enter and we're not in an input/button, handle row selection/activation\n    if ((e.key === \" \" || e.key === \"Enter\") && \n        !(e.target as HTMLElement).matches('input, button, [role=\"button\"], [contenteditable=\"true\"]')) {\n      // Prevent default behavior\n      e.preventDefault();\n      \n      // Find the focused row or cell\n      const focusedElement = document.activeElement;\n      if (focusedElement && (\n          focusedElement.getAttribute('role') === 'row' || \n          focusedElement.getAttribute('role') === 'gridcell'\n      )) {\n        // Find the closest row\n        const rowElement = focusedElement.getAttribute('role') === 'row' \n          ? focusedElement \n          : focusedElement.closest('[role=\"row\"]');\n          \n        if (rowElement) {\n          // Get the row index from the data-row-index attribute or the row id\n          const rowId = rowElement.getAttribute('data-row-index') || rowElement.id;\n          if (rowId) {\n            // Find the row by index and toggle its selection\n            const rowIndex = Number.parseInt(rowId.replace(/^row-/, ''), 10);\n            const row = table.getRowModel().rows[rowIndex];\n            if (row) {\n              if (e.key === \" \") {\n                // Space toggles selection\n                row.toggleSelected();\n              } else if (e.key === \"Enter\" && onRowActivate) {\n                // Enter activates the row\n                onRowActivate(row.original, rowIndex);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n} "
    },
    {
      "path": "registry/default/components/data-table/utils/search.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/search.ts",
      "content": "/**\n * Preprocess search terms before sending to API\n * \n * - Trims whitespace\n * - Removes excessive spaces\n * - Sanitizes potentially harmful characters\n * - Returns empty string for invalid inputs\n */\nexport function preprocessSearch(searchTerm: string): string {\n  if (!searchTerm) return \"\";\n  \n  // Trim whitespace\n  let processed = searchTerm.trim();\n  \n  // Remove excessive whitespace within the search term\n  processed = processed.replace(/\\s+/g, ' ');\n  \n  // Check for minimum length after processing (e.g., if it's just spaces)\n  if (processed.length < 1) return \"\";\n  \n  // Comprehensive sanitization for XSS protection\n  // Remove script tags and potentially harmful HTML/JS patterns\n  processed = processed.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\n  processed = processed.replace(/javascript:/gi, '');\n  processed = processed.replace(/on\\w+\\s*=/gi, '');\n  \n  // HTML entity encoding for common XSS vectors\n  processed = processed.replace(/&/g, '&amp;')\n                     .replace(/</g, '&lt;')\n                     .replace(/>/g, '&gt;')\n                     .replace(/\"/g, '&quot;')\n                     .replace(/'/g, '&#x27;')\n                     .replace(/\\//g, '&#x2F;');\n  \n  return processed;\n}\n"
    },
    {
      "path": "registry/default/components/data-table/utils/table-config.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/table-config.ts",
      "content": "/**\n * Table configuration options\n * This file provides centralized configuration for the data table features\n */\nexport interface TableConfig {\n  // Enable/disable row selection\n  enableRowSelection: boolean;\n  \n  // Enable/disable keyboard navigation\n  enableKeyboardNavigation: boolean;\n  \n  // Enable/disable clicking a row to select it\n  enableClickRowSelect: boolean;\n  \n  // Enable/disable pagination\n  enablePagination: boolean;\n  \n  // Enable/disable search\n  enableSearch: boolean;\n  \n  // Enable/disable column filters\n  enableColumnFilters: boolean;\n  \n  // Enable/disable date range filter\n  enableDateFilter: boolean;\n  \n  // Enable/disable column visibility options\n  enableColumnVisibility: boolean;\n  \n  // Enable/disable data export\n  enableExport: boolean;\n  \n  // Enable/disable URL state persistence\n  enableUrlState: boolean;\n  \n  // Enable/disable column resizing\n  enableColumnResizing: boolean;\n  \n  // Enable/disable toolbar\n  enableToolbar: boolean;\n  \n  // Control the size of buttons and inputs throughout the table\n  // sm: small, default: standard, lg: large\n  size: 'sm' | 'default' | 'lg';\n  \n  // Unique ID for storing column sizing in localStorage\n  // This allows multiple tables to have independent sizing states\n  columnResizingTableId?: string;\n  \n  // Custom placeholder text for search input\n  // If not provided, defaults to \"Search {entityName}...\"\n  searchPlaceholder?: string;\n  \n  // Allow exporting new columns created by transform function\n  // When true (default): Export includes visible columns + new columns from transform function\n  // When false: Export only includes visible columns (hidden columns always excluded)\n  // Note: Hidden columns are ALWAYS excluded regardless of this setting\n  allowExportNewColumns: boolean;\n\n  // Default sort column (should match column accessorKey exactly)\n  // Use the same case format as your API response (snake_case or camelCase)\n  defaultSortBy?: string;\n\n  // Default sort direction\n  defaultSortOrder?: 'asc' | 'desc';\n}\n\n// Default configuration\nconst defaultConfig: TableConfig = {\n  enableRowSelection: true,      // Row selection enabled by default\n  enableKeyboardNavigation: false, // Keyboard navigation disabled by default\n  enableClickRowSelect: false,    // Clicking row to select disabled by default\n  enablePagination: true,         // Pagination enabled by default\n  enableSearch: true,             // Search enabled by default\n  enableColumnFilters: true,      // Column filters enabled by default\n  enableDateFilter: true,         // Date filter enabled by default\n  enableColumnVisibility: true,   // Column visibility options enabled by default\n  enableExport: true,             // Data export enabled by default\n  enableUrlState: true,           // URL state persistence enabled by default\n  enableColumnResizing: true,     // Column resizing enabled by default\n  enableToolbar: true,            // Toolbar enabled by default\n  size: 'default',                // Default size for buttons and inputs\n  columnResizingTableId: undefined, // No table ID by default\n  searchPlaceholder: undefined,   // No custom search placeholder by default\n  allowExportNewColumns: true,    // Allow new columns from transform function by default\n  defaultSortBy: undefined,       // No default sort column - must be provided in config\n  defaultSortOrder: 'desc',       // Default to descending order\n};\n\n/**\n * Hook to provide table configuration\n * Allows overriding default configuration\n */\nexport function useTableConfig(overrideConfig?: Partial<TableConfig>): TableConfig {\n  // Merge default config with any overrides\n  const config = { ...defaultConfig, ...overrideConfig };\n  \n  return config;\n} "
    },
    {
      "path": "registry/default/components/data-table/utils/table-state-handlers.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/table-state-handlers.ts",
      "content": "import type { SortingState, ColumnFiltersState, VisibilityState, PaginationState, ColumnSizingState } from \"@tanstack/react-table\";\n\ntype SortingUpdater = (prev: SortingState) => SortingState;\ntype StatePromise = Promise<URLSearchParams> | undefined;\ntype SetStateFunction<T> = (value: T | ((prev: T) => T)) => StatePromise;\n\n/**\n * Handler for sorting changes in a data table\n * Ensures that sortBy is updated before sortOrder for proper synchronization\n */\nexport function createSortingHandler(\n  setSortBy: SetStateFunction<string>,\n  setSortOrder: SetStateFunction<\"asc\" | \"desc\">\n) {\n  return (updaterOrValue: SortingState | SortingUpdater): void => {\n    // Handle both direct values and updater functions\n    const newSorting = typeof updaterOrValue === 'function'\n      ? updaterOrValue([])\n      : updaterOrValue;\n    \n    // Only update if there's a valid sorting instruction\n    if (newSorting.length > 0) {\n      const columnId = newSorting[0].id;\n      const direction = newSorting[0].desc ? \"desc\" : \"asc\";\n      \n      // Important: Sequential updates to ensure proper synchronization\n      // First update the column id\n      const sortByResult = setSortBy(columnId);\n      \n      if (sortByResult instanceof Promise) {\n        // If using URL state (Promise-based), chain the updates\n        sortByResult.then(() => {\n          // Then set the sort direction\n          setSortOrder(direction);\n        });\n      } else {\n        // If using regular state (non-Promise), just update sequentially\n        setSortOrder(direction);\n      }\n    }\n    // Don't reset to defaults when sort is explicitly cleared\n    // This prevents overriding user selections with default values\n  };\n}\n\n/**\n * Handler for column filters changes in a data table\n */\nexport function createColumnFiltersHandler(\n  setColumnFilters: SetStateFunction<ColumnFiltersState>\n) {\n  return (updaterOrValue: ColumnFiltersState | ((prev: ColumnFiltersState) => ColumnFiltersState)) => {\n    // Pass through to setColumnFilters (which handles updater functions)\n    setColumnFilters(updaterOrValue);\n  };\n}\n\n/**\n * Handler for column visibility changes in a data table\n */\nexport function createColumnVisibilityHandler(\n  setColumnVisibility: SetStateFunction<VisibilityState>\n) {\n  return (updaterOrValue: VisibilityState | ((prev: VisibilityState) => VisibilityState)) => {\n    // Pass through to setColumnVisibility (which handles updater functions)\n    setColumnVisibility(updaterOrValue);\n  };\n}\n\n/**\n * Handler for pagination changes in a data table\n */\nexport function createPaginationHandler(\n  setPage: SetStateFunction<number>,\n  setPageSize: SetStateFunction<number>,\n  currentPage: number,\n  currentPageSize: number\n) {\n  return (updaterOrValue: PaginationState | ((prev: PaginationState) => PaginationState)) => {\n    // Handle both direct values and updater functions\n    const newPagination = typeof updaterOrValue === 'function'\n      ? updaterOrValue({ pageIndex: currentPage - 1, pageSize: currentPageSize })\n      : updaterOrValue;\n    \n    setPage(newPagination.pageIndex + 1);\n    setPageSize(newPagination.pageSize);\n  };\n}\n\n/**\n * Handler for column sizing changes in a data table\n */\nexport function createColumnSizingHandler(\n  setColumnSizing: SetStateFunction<ColumnSizingState>,\n  columnSizing: ColumnSizingState\n) {\n  return (updaterOrValue: ColumnSizingState | ((prev: ColumnSizingState) => ColumnSizingState)) => {\n    // Handle both direct values and updater functions\n    const newSizing = typeof updaterOrValue === 'function'\n      ? updaterOrValue(columnSizing)\n      : updaterOrValue;\n    setColumnSizing(newSizing);\n  };\n}\n\n/**\n * Convert URL sorting parameters to TanStack Table SortingState\n */\nexport function createSortingState(\n  sortBy?: string, \n  sortOrder?: \"asc\" | \"desc\"\n): SortingState {\n  return sortBy && sortOrder\n    ? [{ id: sortBy, desc: sortOrder === \"desc\" }]\n    : [];\n} "
    },
    {
      "path": "registry/default/components/data-table/utils/url-state.ts",
      "type": "registry:lib",
      "target": "components/data-table/utils/url-state.ts",
      "content": "// ** import core packages\nimport { usePathname, useRouter, useSearchParams } from \"next/navigation\";\nimport { useCallback, useState, useEffect, useRef, useMemo } from \"react\";\n\n// ** import utils\nimport { isDeepEqual } from \"./deep-utils\";\n\n// Batch update state management with instance tracking to prevent race conditions\ninterface BatchUpdateState {\n  isInBatchUpdate: boolean;\n  batchId: number;\n  pendingUpdates: Map<string, PendingUpdateEntry>;\n}\n\ninterface PendingUpdateEntry<T = unknown> {\n  value: T;\n  defaultValue: T;\n  serialize: (value: T) => string;\n  areEqual: (a: T, b: T) => boolean;\n}\n\n// Global state with proper isolation\nconst batchUpdateState: BatchUpdateState = {\n  isInBatchUpdate: false,\n  batchId: 0,\n  pendingUpdates: new Map<string, PendingUpdateEntry>(),\n};\n\n// Timeout to prevent stuck batch updates\nlet batchTimeoutId: NodeJS.Timeout | null = null;\nconst BATCH_TIMEOUT = 100; // 100ms timeout for batch updates\n\n// Track the last URL update to ensure it's properly applied\nconst lastUrlUpdate = {\n  timestamp: 0,\n  params: new URLSearchParams(),\n};\n\n/**\n * Custom hook for managing URL-based state\n * This provides a simpler approach for storing state in URL params\n */\nexport function useUrlState<T>(\n  key: string,\n  defaultValue: T,\n  options: {\n    serialize?: (value: T) => string;\n    deserialize?: (value: string) => T;\n  } = {}\n) {\n  const router = useRouter();\n  const pathname = usePathname();\n  const searchParams = useSearchParams();\n\n  // Use ref to track if we're currently updating URL\n  // This prevents recursive updates when router changes trigger effects\n  const isUpdatingUrl = useRef(false);\n\n  // Add a reference to track the last value we updated to\n  const lastSetValue = useRef<T>(defaultValue);\n\n  // Custom serialization/deserialization functions\n  const serialize =\n    options.serialize ||\n    ((value: T) =>\n      typeof value === \"object\" ? JSON.stringify(value) : String(value));\n\n  const deserialize =\n    options.deserialize ||\n    ((value: string) => {\n      try {\n        if (typeof defaultValue === \"number\") {\n          const num = Number(value);\n          // Check if the parsed value is a valid number\n          if (Number.isNaN(num)) return defaultValue;\n          return num as unknown as T;\n        }\n\n        if (typeof defaultValue === \"boolean\") {\n          return (value === \"true\") as unknown as T;\n        }\n\n        if (typeof defaultValue === \"object\") {\n          try {\n            const parsed = JSON.parse(value) as T;\n            // Validate the structure matches what we expect\n            if (parsed && typeof parsed === \"object\") {\n              // For dateRange, check if it has the expected properties\n              if (key === \"dateRange\") {\n                const dateRange = parsed as {\n                  from_date?: string;\n                  to_date?: string;\n                };\n                if (!dateRange.from_date || !dateRange.to_date) {\n                  console.warn(`Invalid dateRange format in URL: ${value}`);\n                  return defaultValue;\n                }\n              }\n              return parsed;\n            }\n            return defaultValue;\n          } catch (e) {\n            console.warn(`Error parsing JSON from URL parameter ${key}: ${e}`);\n            return defaultValue;\n          }\n        }\n\n        return value as unknown as T;\n      } catch (e) {\n        console.warn(`Error deserializing URL parameter ${key}: ${e}`);\n        return defaultValue;\n      }\n    });\n\n  // Get the initial value from URL or use default\n  const getValueFromUrl = useCallback(() => {\n    // Check if we have a pending update for this key that hasn't been applied yet\n    if (batchUpdateState.pendingUpdates.has(key)) {\n      const pendingUpdate = batchUpdateState.pendingUpdates.get(key);\n      if (pendingUpdate && typeof pendingUpdate.value !== 'undefined') {\n        return pendingUpdate.value as T;\n      }\n    }\n\n    const paramValue = searchParams.get(key);\n    if (paramValue === null) {\n      return defaultValue;\n    }\n\n    // Special handling for search parameter to decode URL-encoded spaces\n    if (key === \"search\" && typeof defaultValue === \"string\") {\n      return decodeURIComponent(paramValue) as unknown as T;\n    }\n\n    return deserialize(paramValue);\n  }, [searchParams, key, deserialize, defaultValue]);\n\n  // State to store the current value\n  const [value, setValue] = useState<T>(getValueFromUrl);\n\n  // Track the previous search params to avoid unnecessary updates\n  const prevSearchParamsRef = useRef<URLSearchParams | null>(null);\n\n  // Deep compare objects/arrays before updating state\n  const areEqual = useMemo(() => {\n    return (a: T, b: T): boolean => {\n      if (typeof a === \"object\" && typeof b === \"object\") {\n        return isDeepEqual(a, b);\n      }\n      return a === b;\n    };\n  }, []);\n\n  // Keep a ref to track the current value to avoid dependency on the state variable\n  const currentValueRef = useRef<T>(value);\n  \n  // Update currentValueRef whenever value changes\n  useEffect(() => {\n    currentValueRef.current = value;\n  }, [value]);\n\n  // Update state when URL changes, but only if we're not the ones changing it\n  useEffect(() => {\n    // Skip if we're the ones currently updating the URL\n    if (isUpdatingUrl.current) {\n      isUpdatingUrl.current = false;\n      return;\n    }\n\n    // Check if searchParams actually changed\n    const searchParamsString = searchParams.toString();\n    if (\n      prevSearchParamsRef.current &&\n      prevSearchParamsRef.current.toString() === searchParamsString\n    ) {\n      return;\n    }\n\n    // Update the previous search params ref\n    const newParams = new URLSearchParams(searchParamsString);\n    prevSearchParamsRef.current = newParams;\n\n    // Get the new value and update if different\n    const newValue = getValueFromUrl();\n\n    // Check if this is a value we just set ourselves\n    // Using refs to track state without creating dependencies\n    if (\n      !areEqual(lastSetValue.current, newValue) && \n      !areEqual(currentValueRef.current, newValue)\n    ) {\n      // Prevent immediate re-triggering of this effect due to state update\n      lastSetValue.current = newValue;\n      setValue(newValue);\n    } else if (\n      batchUpdateState.pendingUpdates.has(key) &&\n      areEqual(batchUpdateState.pendingUpdates.get(key)?.value as unknown as T, newValue)\n    ) {\n      // If our pending update has been applied, we can remove it from the map\n      batchUpdateState.pendingUpdates.delete(key);\n    }\n  }, [searchParams, getValueFromUrl, key, areEqual]); // No dependency on value\n\n  // Synchronously update URL now instead of waiting\n  const updateUrlNow = useCallback(\n    (params: URLSearchParams) => {\n      const now = Date.now();\n      lastUrlUpdate.timestamp = now;\n      lastUrlUpdate.params = params;\n\n      // Update the URL immediately\n      const newParamsString = params.toString();\n      router.replace(\n        `${pathname}${newParamsString ? `?${newParamsString}` : \"\"}`\n      );\n\n      // Clear the updating flag after URL update\n      isUpdatingUrl.current = false;\n\n      // Return the params for Promise chaining\n      return Promise.resolve(params);\n    },\n    [router, pathname]\n  );\n\n  // Update the URL when the state changes\n  const updateValue = useCallback(\n    (newValue: T | ((prevValue: T) => T)) => {\n      const resolvedValue =\n        typeof newValue === \"function\"\n          ? (newValue as (prev: T) => T)(value)\n          : newValue;\n\n      // Skip update if value is the same (deep comparison for objects)\n      if (areEqual(value, resolvedValue)) {\n        return Promise.resolve(new URLSearchParams(searchParams.toString()));\n      }\n\n      // Save this value to our ref to prevent overrides\n      lastSetValue.current = resolvedValue;\n\n      // Store the value, defaultValue, serialize, and areEqual in the pending updates map\n      batchUpdateState.pendingUpdates.set(key, {\n        value: resolvedValue,\n        defaultValue,\n        serialize: serialize as (value: unknown) => string,\n        areEqual: areEqual as (a: unknown, b: unknown) => boolean,\n      });\n\n      // Set state locally first for immediate UI response\n      setValue(resolvedValue);\n\n      // Set flag to prevent recursive updates\n      isUpdatingUrl.current = true;\n\n      // Handle pageSize and page relationship - ensure page is reset to 1 when pageSize changes\n      if (key === \"pageSize\") {\n        // If pageSize changes, \"page\" should be reset to 1.\n        // We need to ensure this \"page\" entry has appropriate functions.\n        // For now, assume standard defaults for \"page\" if it's not already managed by its own useUrlState.\n        // A more robust solution might involve a shared registry or context for URL state configurations.\n        const pageEntry: PendingUpdateEntry<number> = batchUpdateState.pendingUpdates.get(\"page\") as PendingUpdateEntry<number> || {\n          value: 1,\n          defaultValue: 1, // Assuming default page is 1\n          serialize: (v: number) => String(v),\n          areEqual: (a: number, b: number) => a === b,\n        };\n        batchUpdateState.pendingUpdates.set(\"page\", { ...pageEntry, value: 1 } as PendingUpdateEntry<unknown>);\n      }\n\n      // If we're in a batch update, delay URL change\n      if (batchUpdateState.isInBatchUpdate) {\n        return Promise.resolve(new URLSearchParams(searchParams.toString()));\n      }\n\n      // Start a batch update to collect multiple URL changes in the current event loop\n      batchUpdateState.isInBatchUpdate = true;\n      batchUpdateState.batchId++;\n      const currentBatchId = batchUpdateState.batchId;\n\n      // Clear any existing timeout\n      if (batchTimeoutId) {\n        clearTimeout(batchTimeoutId);\n      }\n\n      // Use microtask to batch all URL changes in the current event loop\n      return new Promise<URLSearchParams>((resolve) => {\n        const processBatch = () => {\n          // Check if this batch is still valid (not superseded by a newer batch)\n          if (currentBatchId !== batchUpdateState.batchId) {\n            return;\n          }\n          // Start with the current search params as a base\n          const params = new URLSearchParams(searchParams.toString());\n          let pageSizeChangedInBatch = false;\n\n          // Keep track if any sort parameters are in the current batch\n          let sortByInBatch = false;\n          let sortOrderInBatch = false;\n          \n          // Check if sortBy/sortOrder are already in the URL\n          const sortByInURL = params.has(\"sortBy\");\n          const defaultSortOrder = \"desc\"; // Match the default from the component\n          \n          // First pass: identify which sort parameters are being updated\n          for (const [updateKey, _] of batchUpdateState.pendingUpdates.entries()) {\n            if (updateKey === \"sortBy\") sortByInBatch = true;\n            if (updateKey === \"sortOrder\") sortOrderInBatch = true;\n          }\n          \n          // Iterate over all pending updates and apply them to the params\n          for (const [updateKey, entry] of batchUpdateState.pendingUpdates.entries()) {\n            const {\n              value: updateValue,\n              defaultValue: entryDefaultValue,\n              serialize: entrySerialize,\n              areEqual: entryAreEqual,\n            } = entry;\n\n            // Special case: Always include sort-related parameters to ensure URL consistency\n            if (updateKey === \"sortBy\") {\n              // When setting sortBy, always include it in URL\n              params.set(updateKey, entrySerialize(updateValue));\n              \n              // If sortOrder isn't being updated in this batch, ensure it's included\n              if (!sortOrderInBatch) {\n                // Get current sortOrder value from URL or use default\n                const currentSortOrder = params.get(\"sortOrder\") || defaultSortOrder;\n                params.set(\"sortOrder\", currentSortOrder);\n              }\n            } \n            else if (updateKey === \"sortOrder\") {\n              // Always include sortOrder when sortBy is present (either in URL or in this batch)\n              if (sortByInURL || sortByInBatch) {\n                params.set(updateKey, entrySerialize(updateValue));\n              }\n              else if (entryAreEqual(updateValue, entryDefaultValue)) {\n                params.delete(updateKey);\n              }\n              else {\n                params.set(updateKey, entrySerialize(updateValue));\n              }\n            }\n            else if (entryAreEqual(updateValue, entryDefaultValue)) {\n              params.delete(updateKey);\n            } \n            else {\n              // Special handling for search parameter to preserve spaces\n              if (updateKey === \"search\" && typeof updateValue === \"string\") {\n                // Use encodeURIComponent to properly encode spaces as %20 instead of +\n                params.set(updateKey, encodeURIComponent(updateValue));\n              } else {\n                params.set(updateKey, entrySerialize(updateValue));\n              }\n            }\n            if (updateKey === \"pageSize\") {\n              pageSizeChangedInBatch = true;\n            }\n          }\n\n          // If pageSize was part of this batch update, ensure page is set to 1\n          // This handles the case where \"page\" might have been set to something else\n          // in the same batch, but a pageSize change should override it to 1.\n          if (pageSizeChangedInBatch) {\n            params.set(\"page\", \"1\");\n          }\n          \n          // Clear all pending updates as they've been processed\n          batchUpdateState.pendingUpdates.clear();\n\n          // End the batch update\n          batchUpdateState.isInBatchUpdate = false;\n\n          // Clear the timeout since we're processing now\n          if (batchTimeoutId) {\n            clearTimeout(batchTimeoutId);\n            batchTimeoutId = null;\n          }\n\n          // Update the URL immediately and resolve\n          updateUrlNow(params).then(resolve);\n        };\n\n        // Process batch in microtask\n        queueMicrotask(processBatch);\n\n        // Also set a timeout as fallback to prevent stuck batches\n        batchTimeoutId = setTimeout(processBatch, BATCH_TIMEOUT);\n      });\n    },\n    [\n      searchParams,\n      key,\n      serialize,\n      value,\n      defaultValue,\n      updateUrlNow,\n      areEqual\n    ]\n  );\n\n  return [value, updateValue] as const;\n}\n\n// Helper to convert a date object to YYYY-MM-DD format\nexport function formatDateForUrl(date: Date | undefined): string {\n  if (!date) return \"\";\n  return date.toISOString().split(\"T\")[0];\n}\n\n// Helper to safely validate and parse date strings from URL\nexport function validateDateString(dateString: string): boolean {\n  if (!dateString) return false;\n\n  // Check if it's in YYYY-MM-DD format\n  const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  if (!dateRegex.test(dateString)) return false;\n\n  // Check if it's a valid date\n  const date = new Date(dateString);\n  return !Number.isNaN(date.getTime());\n}\n\n// Helper to parse a YYYY-MM-DD string to a Date object\nexport function parseDateFromUrl(dateString: string): Date | undefined {\n  if (!validateDateString(dateString)) return undefined;\n  return new Date(dateString);\n}\n"
    }
  ]
}